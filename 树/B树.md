https://zhuanlan.zhihu.com/p/27700617

https://troywu0.gitbooks.io/spark/content/bshu_b_shu.html

http://blog.jobbole.com/111757/

https://github.com/julycoding/The-Art-Of-Programming-By-July/blob/master/ebook/zh/03.02.md

https://www.cnblogs.com/nullzx/p/8729425.html

从算法逻辑上看，二叉查找树的查找速度和比较次数最小的。但是我们不得不考虑 一个现实问题：磁盘IO。

数据库索引是存储在磁盘上的，当数据量较大的时候，索引的大小可能会有有几G甚至更多。在我们利用索引查询的时候，不可能将整个索引全部加载到内存中。能做的只有逐一加载每一个磁盘页（磁盘页对应着索引树的节点）。

如果按照二叉查找树的方法查找节点10，需要磁盘IO次数为4次
![img](BTree2.jpg)

由此可以看到，最坏的情况下，磁盘IO次数等于树的高度。为了减少磁盘IO次数，我们就需要把原本瘦高的二叉树，变为胖矮的树。这就是B-树的特征。

## B-树

> 读B树，不是B减树

B树和平衡二叉树稍有不同的是B树属于多叉树又名平衡多路查找树（查找路径不只两个），数据库索引技术里大量使用者B树和B+树的数据结构

​      (1). 定义任意非叶子节点最多有M个儿子，且M>2; (M一般取决于磁盘页的大小)

​       (2). 根节点的儿子数为[2,M];

​       (3). 除根节点以外的非叶子节点的儿子数为[M/2,M];

​       (4). 每个节点存放至少M/2-1(取上整)和至多M-1个关键字

​       (5). 非叶子节点的关键字个数=指向儿子节点的指针的个数-1;  

​       (6). 非叶子节点的关键字：k[i]<k[i+1];

​       (7). 非叶子节点的指针：p[1]，p[2]，·····，p[M]；其中p[1]指向的关键字小于k[1]的子树，p[M]指向的关键字大于K[m-1]的子树;

​       (8). 所有的叶子节点位于同一层; 

例如：下面就是一棵3阶B~树

(为了简单，这里用少量数据构造一棵2-4树的形式，其实实际应用中的B树结点中关键字很多的)

![img](BTree1.jpg)

虽然B-树在查询中的比较次数并不比二叉查找树少，但是相比磁盘IO的速度，内存中的查找耗时几乎可以忽略，所以，只要树的高度足够低，IO次数足够少就可以提升查找性能。

## 插入

在下图的B树中插入4
![img](BTree3.jpg)

自顶向下查找4的节点位置，发现4应当插入到节点元素3，5之间。 节点3，5已经是两元素节点，无法再增加。父亲节点 2， 6 也是两元素节点，也无法再增加。根节点9是单元素节点，可以升级为两元素节点。于是**拆分**节点3，5与节点2，6，让根节点9升级为两元素节点4，9。节点6独立为根节点的第二个孩子。 

![img](BTree4.jpg)

上面的例子有点模糊，下面看一个更详细的例子

针对一棵高度为h的m阶B树，插入一个元素时，首先在B树中是否存在，如果不存在，一般在叶子结点中插入该新的元素，此时分3种情况：

- 如果叶子结点空间足够，即该结点的关键字数小于m-1，则直接插入在叶子结点的左边或右边；
- 如果空间满了以致没有足够的空间去添加新的元素，即该结点的关键字数已经有了m个，则需要将该**结点**进行“分裂”，将一半数量的关键字元素分裂到新的其相邻右结点中，中间关键字元素上移到父结点中，而且当结点中关键元素向右移动了，相关的指针也需要向右移。
- 此外，如果在上述中间关键字上移到父结点的过程中，导致根结点空间满了，那么根结点也要进行分裂操作，这样原来的根结点中的中间关键字元素向上移动到新的根结点中，因此导致树的高度增加一层。

下面咱们通过一个实例来逐步讲解下。插入以下字符字母到一棵空的5阶B 树中：C N G A H E K Q M F W L T Z D P R X Y S，而且，因为是5阶B树，所以必有非根结点**关键字数**小了（小于2个）就合并，大了（超过4个）就分裂。

1. 首先，结点空间足够，刚开始的4个字母可以直接到插入相同的结点中，如下图：

![img](BTree10.jpg)

2. 插入H结点时，发现结点空间不够，所以将其分裂成2个结点，移动中间元素G上移到新的根结点中，且把A和C留在当前结点中，而H和N放置在新的右邻居结点中。如下图：

![img](BTree11.jpg)

3. 当插入E,K,Q时，不需要任何分裂操作

![img](BTree12.jpg)

4. 插入M需要一次分裂，注意到M恰好是中间关键字元素，所以M向上移到父节点中

![img](BTree13.jpg)

5. 插入F,W,L,T不需要任何分裂操作

![img](BTree14.jpg)

6. 插入Z时，最右的叶子结点空间满了，需要进行分裂操作，中间元素T上移到父节点中 

![img](BTree15.jpg)

7. 插入D时，导致最左边的叶子结点被分裂，D恰好也是中间元素，上移到父节点中，然后字母P,R,X,Y直接陆续插入，不需要任何分裂操作

![img](BTree16.jpg)

8. 最后，当插入S时，含有N,P,Q,R的结点需要分裂，把中间元素Q上移到父节点中，但是问题来了，因为Q上移导致父结点 “D G M T” 也满了，所以也要进行分裂，将父结点中的中间元素M上移到新形成的根结点中，从而致使树的高度增加一层

![img](BTree17.jpg)

## 删除

删除下图中的11

![img](BTree5.jpg)

自顶向下查找元素11的节点位置，删除11后，节点12只有一个孩子，不符合B树规范，进行左旋

![img](BTree6.jpg)



下面介绍删除操作，删除操作相对于插入操作要考虑的情况多点。

- 首先查找B树中需删除的元素,如果该元素在B树中存在，则将该元素在其结点中进行删除，如果删除该元素后，首先判断该元素是否有左右孩子结点
- 如果有，则上移孩子结点中的某相近元素(“左孩子最右边的节点”或“右孩子最左边的节点”)到父节点中，然后是移动之后的情况；
- 如果没有，直接删除后，移动之后的情况。

删除元素，移动相应元素之后，如果某结点中元素数目（即关键字数）小于**ceil(m/2)-1**，则需要看其某相邻兄弟结点是否丰满（结点中元素个数大于ceil(m/2)-1）

- 如果丰满，则向父节点借一个元素来满足条件；
- 如果其相邻兄弟都刚脱贫，即借了之后其结点数目小于ceil(m/2)-1，则该结点与其相邻的某一兄弟结点进行“合并”成一个结点，以此来满足条件。

下面咱们还是以上述插入操作构造的一棵5阶B树（**树中除根结点和叶子结点外的任意结点的孩子数m满足3<=m<=5，除根结点外的任意结点的关键字数n满足：2<=n<=4，所以关键字数小于2个就合并，超过4个就分裂**）为例，依次删除H,T,R,E。

![img](BTree20.jpg)

1. 首先删除元素H，当然首先查找H，H在一个叶子结点中，且该叶子结点元素数目3大于最小元素数目ceil(m/2)-1=2，则操作很简单，咱们只需要移动K至原来H的位置，移动L至K的位置（也就是结点中删除元素后面的元素向前移动）

![img](BTree22.jpg)

2. 下一步，删除T,因为T没有在叶子结点中，而是在中间结点中找到，咱们发现他的继承者W(字母升序的下个元素)，将W上移到T的位置，然后将原包含W的孩子结点中的W进行删除，这里恰好删除W后，该孩子结点中元素个数大于2，无需进行合并操作。

![img](BTree23.jpg)

3. 下一步删除R，R在叶子结点中,但是该结点中元素数目为2，删除导致只有1个元素，已经小于最小元素数目ceil(5/2)-1=2,而由前面我们已经知道：**如果其某个相邻兄弟结点中比较丰满（元素个数大于ceil(5/2)-1=2），则可以向父结点借一个元素，然后将最丰满的相邻兄弟结点中上移最后或最前一个元素到父节点中**（有没有看到红黑树中左旋操作的影子?）。 故在这个实例中，由于右相邻兄弟结点“X Y Z”比较丰满，而删除元素R后，导致“S”结点稀缺

- 所以原来的的“R S”结点先向父节点借一个元素W下移到该叶子结点中，代替原来S的位置，S前移；
- 然后相邻右兄弟结点中的X上移到父结点中；
- 最后相邻右兄弟结点中元素Y和Z前移。

![img](BTree24.jpg)

1. 最后一步删除E， 删除后会导致很多问题，因为E所在的结点数目刚好达标，刚好满足最小元素个数（ceil(5/2)-1=2）,而相邻的兄弟结点也是同样的情况，删除一个元素都不能满足条件，所以需要**该节点与某相邻兄弟结点进行合并操作**；

- 首先移动父结点中的元素（该元素在两个需要合并的两个结点元素之间）下移到其子结点中，
- 然后将这两个结点进行合并成一个结点。所以在该实例中，咱们首先将父节点中的元素D下移到已经删除E而只有F的结点中，然后将含有D和F的结点和含有A,C的相邻兄弟结点进行合并成一个结点。

![img](BTree25.jpg)

也许你认为这样删除操作已经结束了，其实不然，在看看上图，对于这种特殊情况，你立即会发现父节点只包含一个元素G，没达标（因为非根节点包括叶子结点的关键字数n必须满足于2=<n<=4，而此处的n=1），这是不能够接受的。如果这个问题结点的相邻兄弟比较丰满，则可以向父结点借一个元素。假设这时右兄弟结点（含有Q,X）有一个以上的元素（Q右边还有元素），然后咱们将M下移到元素很少的子结点中，将Q上移到M的位置，这时，Q的左子树将变成M的右子树，也就是含有N，P结点被依附在M的右指针上。

所以在这个实例中，咱们没有办法去借一个元素，只能与兄弟结点进行合并成一个结点，而根结点中的唯一元素M下移到子结点，这样，树的高度减少一层。

![img](BTree26.jpg)

为了进一步详细讨论删除的情况，**再举另外一个实例**：
 这里是一棵不同的5序B树，那咱们试着删除C

![img](BTree27.jpg)

 于是将删除元素C的右子结点中的D元素上移到C的位置，但是出现上移元素后，只有一个元素的结点的情况。
 又因为含有E的结点，其相邻兄弟结点才刚脱贫（最少元素个数为2），不可能向父节点借元素，所以只能进行合并操作，于是这里将含有A,B的左兄弟结点和含有E的结点进行合并成一个结点。

![img](BTree28.jpg)

 这样又出现只含有一个元素F结点的情况，这时，其相邻的兄弟结点是丰满的（元素个数为3>最小元素个数2），这样就可以想父结点借元素了，把父结点中的J下移到该结点中，相应的如果结点中J后有元素则前移，然后相邻兄弟结点中的第一个元素（或者最后一个元素）上移到父节点中，后面的元素（或者前面的元素）前移（或者后移）；注意含有K，L的结点以前依附在M的左边，现在变为依附在J的右边。这样每个结点都满足B树结构性质。

![img](BTree29.jpg)

 从以上操作可看出：除根结点之外的结点（包括叶子结点）的关键字的个数n满足：（ceil(m / 2)-1）<= n <= m-1，即2<=n<=4。这也佐证了咱们之前的观点。删除操作完。