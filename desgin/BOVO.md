这些概念用于描述对象的类型；由于java是面向对象的语言；程序的世界就是各个对象之间的“交互”；在交互的工程中会存在多个层次，每个层次中所拥有（关注）的内容都是不一样的；

- PO(Persistant Object) 持久对象 
   用于表示数据库中的一条记录映射成的 java 对象。PO 仅仅用于表示数据，没有任何数据操作。通常遵守 Java Bean 的规范，拥有 getter/setter 方法。

  可以理解是一个PO就是数据库中的一条记录；可以理解某个事务依赖的原始数据；好处是可以将一条记录最为一个对象处理，可以方便转化为其他对象

- BO(Business Object) 业务对象 
   封装对象、复杂对象，里面可能包含多个类 
   主要作用是把业务逻辑封装为一个对象。这个对象可以包括一个或多个其它的对象。

  用于表示一个业务对象。BO 包括了业务逻辑，常常封装了对 DAO、RPC 等的调用，可以进行 PO 与 VO/DTO 之间的转换。BO 通常位于业务层，要区别于直接对外提供服务的服务层：BO 提供了基本业务单元的基本业务操作，在设计上属于被服务层业务流程调用的对象，一个业务流程可能需要调用多个 BO 来完成。

  比如一个简历，有教育经历、工作经历、社会关系等等。 
   我们可以把教育经历对应一个PO，工作经历对应一个PO，社会关系对应一个PO。 
   建立一个对应简历的BO对象处理简历，每个BO包含这些PO。 
   这样处理业务逻辑时，我们就可以针对BO去处理。

- VO(Value Object) 表现对象 
    前端界面展示；value object值对象；ViewObject表现层对象；主要对应界面显示的数据对象。对于一个WEB页面，或者SWT、SWING的一个界面，用一个VO对象对应整个界面的值；对于Android而言即是activity或view中的数据元素。

  用于表示一个与前端进行交互的 java 对象。有的朋友也许有疑问，这里可不可以使用 PO 传递数据？实际上，这里的 VO 只包含前端需要展示的数据即可，对于前端不需要的数据，比如数据创建和修改的时间等字段，出于减少传输数据量大小和保护数据库结构不外泄的目的，不应该在 VO 中体现出来。通常遵守 Java Bean 的规范，拥有 getter/setter 方法。

- DTO(Data Transfer Object) 数据传输对象 
    前端调用时传输；也可理解成“上层”调用时传输; 
    比如我们一张表有100个字段，那么对应的PO就有100个属性。但是我们界面上只要显示10个字段，客户端用WEB service来获取数据，没有必要把整个PO对象传递到客户端，这时我们就可以用只有这10个属性的DTO来传递结果到客户端，这样也不会暴露服务端表结构.到达客户端以后，如果用这个对象来对应界面显示，那此时它的身份就转为VO.

  用于表示一个数据传输对象。DTO 通常用于不同服务或服务不同分层之间的数据传输。DTO 与 VO 概念相似，并且通常情况下字段也基本一致。但 DTO 与 VO 又有一些不同，这个不同主要是设计理念上的，比如 API 服务需要使用的 DTO 就可能与 VO 存在差异。通常遵守 Java Bean 的规范，拥有 getter/setter 方法

- DAO(Data access object) 数据访问对象 
   这个大家最熟悉，和上面几个O区别最大，基本没有互相转化的可能性和必要.，主要用来封装对数据库的访问。通过它可以把POJO持久化为PO，用PO组装出来VO、DTO；

  用于表示一个数据访问对象。使用 DAO 访问数据库，包括插入、更新、删除、查询等操作，与 PO 一起使用。DAO 一般在持久层，完全封装数据库操作，对外暴露的方法使得上层应用不需要关注数据库相关的任何信息。

- POJO(Plain ordinary java object) 简单java对象

一个POJO持久化以后就是PO；直接用它传递、传递过程中就是DTO；直接用来对应表示层就是VO。

举个例子： 
 事情：统计研发部门中的季度绩效（暂定以工程师填写的为准，当然实际上大部分不是） 
 过程：CTO发布统计绩效请求（附带要求：每个人对应的绩效等级）->各个组（也可以是子部门）负责人发布统计绩效请求（每个对应的绩效等级，并将绩效分为了3个方面）->每位开发工程师统计自己绩效（自身各个方面）； 
 可以从例子中看到：每个责任人要求都不同； 
 对于CTO，他需要知道的是该季度所用员工的绩效等级；这里可以认为VO：员工姓名、绩效等级； 
 开发工程师：需将本人这个季度的各个方面的表现都列出来：员工姓名、绩效等级、Ａ方面表现内容及等级、B方面表现内容及等级、C方面表现内容及等级、D方面表现内容及等级、E方面表现内容及等级、F方面表现内容及等级、E方面表现内容及等级；此处可认为是PO：员工姓名、绩效等级、A方面表现内容、A方面等级….E方面表现内容、E方面等级； 
 然后开发工程师将员工姓名、绩效等级、Ａ方面表现内容及等级、B方面表现内容及等级、C方面表现内容及等级内容传递给小组负责人；此处传递的对象就是DTO 
 小组负责人：从开发工程师中获取到数据后，经过评定，然后得出员工姓名、绩效等级、原因；此处的评定，可以理解为ＢＯ；





1. AO（Application Object） ：应用对象。在 Web 层与 Service 层之间抽象的复用对象模型，极为贴近展示层，复用度不高。

   ------

2. BO（Business Object） ：业务对象。由 Service  层输出的封装业务逻辑的对象。业务对象主要作用是把业务逻辑封装为一个对象。这个对象可以包括一个或多个其它的对象。比如一个简历，有教育经历、工作经历、社会关系等等。我们可以把教育经历对应一个PO，工作经历对应一个PO，社会关系对应一个PO。建立一个对应简历的BO对象处理简历，每个BO包含这些PO。这样处理业务逻辑时，我们就可以针对BO去处理。

   ------

3. DO（Data Object） ：与数据库表结构一一对应，通过 DAO 层向上传输数据源对象。

4. DO（Domain Object）领域对象 就是从现实世界中抽象出来的有形或无形的业务实体。一般和数据中的表结构对应。

   ------

5. DAO（Data Access Object ）：数据访问对象——同时还有DAO模式  数据访问对象这个大家最熟悉，和上面几个O区别最大，基本没有互相转化的可能性和必要.主要用来封装对数据库的访问。通常和PO结合使用，DAO中包含了各种数据库的操作方法。它可以把POJO持久化为PO，用PO组装出来VO、DTO

   ------

6. DTO（Data Transfer Object）：数据传输对象——同时还有DTO模式 DTO（Data Transfer  Object） ：数据传输对象， Service 或 Manager  向外传输的对象。数据传输对象主要用于远程调用等需要大量传输对象的地方。比如我们一张表有100个字段，那么对应的PO就有100个属性。但是我们界面上只要显示10个字段，客户端用WEB   service来获取数据，没有必要把整个PO对象传递到客户端，这时我们就可以用只有这10个属性的DTO来传递结果到客户端，这样也不会暴露服务端表结构.到达客户端以后，如果用这个对象来对应界面显示，那此时它的身份就转为VO。

   ------

7. O/R Mapping （Object Relational  Mapping）：是对象关系映射的缩写。通俗点讲，就是将对象与关系数据库绑定，用对象来表示关系数据。在O/R  Mapping的世界里，有两个基本的也是重要的东东需要了解，即VO，PO。它们的关系应该是相互独立的，一个VO可以只是PO的部分，也可以是多个PO构成，同样也可以等同于一个PO（指的是他们的属性）。这样，PO独立出来，数据持久层也就独立出来了，它不会受到任何业务的干涉，业务逻辑层也独立开来，它不会受到数据持久层的影响，业务层关心的只是业务逻辑的处理，不过，如果我们没有使用数据持久层，或者说没有使用hibernate，那么PO和VO也可以是同一个东西，虽然这并不好。

   ------

8. PO（Persistant Object）：全称是持久对象，最形象的理解就是一个PO就是数据库中的一条记录。好处是可以把一条记录作为一个对象处理，可以方便的转为其它对象。

   ------

9. POJO （Plain Ordinary Java Object ）：简单java对象个人感觉POJO是最常见最多变的对象，是一个中间对象，也是我们最常打交道的对象。一个POJO持久化以后就是PO直接用它传递、传递过程中就是DTO直接用来对应表示层就是VO

   ------

10. QO（Query Object）：数据查询对象，各层接收上层的查询请求。注意超过 2 个参数的查询封装，禁止使用 Map 类来传输。

    ------

11. TO（Transfer Object）：数据传输对象，在应用程序不同关系之间传输的对象。 

    ------

12. VO（View Object） ：视图对象 ：显示层对象，通常是 Web 向模板渲染引擎层传输的对象。

13. VO（value object）：值对象。通常用于业务层之间的数据传递，和PO一样也是仅仅包含数据而已。但应是抽象出的业务对象,可以和表对应,也可以不,这根据业务的需要。从前端获取信息用作后端的查询条件。

    ------

- Bean：存放实体类文件
- entity：存放实体类文件
- pojo：存放实体类文件
- model：存放模型类文件
- dataobject：存放数据源对象类文件
- 
- conn:建立了一个数据库连接对象，其他所有涉及到数据库操作的文件都需要包含这个文件并引用该对象。
- dao：存放数据层文件
- repository：和dao层类似，在使用spring data jpa时的常用包名
- mapper：和dao层类似,在使用Mybatis时的常用包名
- 
- service：存放服务层文件
- action：存放服务层文件（在ssh中常用包名）
- manager：存放服务层文件（针对第三方的）
- 
- controller：存放控制层文件
- web：存放控制层文件
- 
- config：存放配置类文件
- enums：存放枚举类文件
- exception：存放异常类文件
- job：存放任务类文件
- 
- utils：存放工具类文件
- tools：存放工具类文件
- aspect：存放切面类文件
- converter：存放转换器文件
- interceptor：存放拦截器文件
- 
- form：
- handler：
- constant：