现在很多系统都有短信验证码的需求，验证码都会有一个时效性，同时也容易被部分用户恶意点击。

# 时效性

时效性最简单的做法就是将验证码放入一个带过期时间的缓存中，在收到用户的验证请求之后，如果在缓存中未找到对应的验证码，则说明验证码已过期。
但是上述做法将导致账户服务依赖于缓存，如果使用JVM堆内存作为缓存，那么该功能在集群情况下将无法扩展。如果使用redis这类分布式缓存，又会让账户服务依赖于redis——为了这么一个小小的功能引入依赖的成本太高。
基于上述考虑，对于验证码的时效性可以采用如下方式判断：

1.  用户请求验证码时除了发送验证码外还需要向调用方返回一段额外的字符串：身份信息.加密信息。身份信息中包括用户手机号、时效性两个部分，加密信息使用验证码对身份信息进行加密（注意：不能简单的使用md5(身份信息，验证码)来进行加密）
2.  用户在输入验证码进行绑定的时候，调用方需要将验证码、手机号、时效性、上一步生成的字符串一起发送到服务端
3.  服务端收到验证码后首先通过身份信息验证验证码是否失效，然后将用户传入的参数组成新的身份信息使用同样的方式对身份信息加密，然后比较两个加密信息是否一致，如果一致则表示验证码正确

# 恶意点击
为了避免短信接口被恶意点击，造成不必要的浪费，可以采用下列的一些方式

1. **绑定图型校验码** 将图形校验码和手机验证码进行绑定，当用户输入手机号码以后，需要输入图形校验码才可以触发短信，这样能比较有效的防止软件恶意点击
2. **流程限定** 将手机短信验证和用户名注册分成两个步骤，用户在注册成功用户名密码后，下一步才进行手机短信验证
3. **触发条件** 用户必须填写好所有注册信息才可进行触发，注册资料不完整无法发送验证码。
4. **短信发送间隔设置** 设置同一号码重复发送的时间间隔，一般设置为60-120秒
5. **IP限定** 设置每个IP每天的最大发送量
6. **发送量限定** 设置每个手机号码每天的最大发送量