https://www.cnblogs.com/siriusckx/articles/3989057.html

## shutdown
```
1、shutdown（）

问：shutdown()有什么功能？

答：阻止新来的任务提交，对已经提交了的任务不会产生任何影响。当已经提交的任务执行完后，它会将那些闲置的线程（idleWorks）进行中断，这个过程是异步的。

问：如何阻止新来的任务提交？

答：通过将线程池的状态改成SHUTDOWN，当再将执行execute提交任务时，如果测试到状态不为RUNNING，则抛出rejectedExecution，从而达到阻止新任务提交的目的。

问：为何对提交的任务不产生任何影响？

答：在调用中断任务的方法时，它会检测workers中的任务，如果worker对应的任务没有中断，并且是空闲线程，它才会去中断。另外的话，workQueue中的值，还是按照一定的逻辑顺序不断的往works中进行输送的，这样一来，就可以保证提交的任务按照线程本身的逻辑执行，不受到影响。
```
示例
```
    ExecutorService executorService = Executors.newFixedThreadPool(5);
    long start = System.currentTimeMillis();
    for (int i=0; i< 10; i ++) {
      int finalI = i;
      executorService.submit(() -> {
        long threadStart = System.currentTimeMillis();
        System.out.println(finalI);
        try {
          TimeUnit.SECONDS.sleep(10);
        } catch (InterruptedException e) {
          System.out.println("interrupted");
        }
        long threadEnd = System.currentTimeMillis();
        System.out.println("end: " + (threadEnd - threadStart));
      });
    }
    TimeUnit.SECONDS.sleep(1);
    executorService.shutdown();
    try {
      executorService.submit(() -> {});
    } catch (Exception e) {
      System.out.println(e.getClass().getSimpleName());
    }
    long end =System.currentTimeMillis();
    System.out.println(end - start);
```
输出

> 0
> 2
> 4
> 3
> 1
> RejectedExecutionException
> 1166
> end: 10001
> end: 10002
> end: 10001
> end: 10002
> 5
> 6
> end: 10001
> 8
> 7
> 9
> end: 10000
> end: 10004
> end: 10004
> end: 10005
> end: 10006
> 可以看到在shutdown后，提交的任务抛出了RejectedExecutionException，之后等所有的任务完成之后才退出，而且每个任务都是运行了10秒左右

## shutdownNow()

问：shutdownNow()有什么功能？

答：阻止新来的任务提交，同时会中断当前正在运行的线程，即workers中的线程。另外它还将workQueue中的任务给移除，并将这些任务添加到列表中进行返回。

问：如何阻止新来的任务提交？

答：通过将线程池的状态改成STOP，当再将执行execute提交任务时，如果测试到状态不为RUNNING，则抛出rejectedExecution，从而达到阻止新任务提交的目的.

问：如果我提交的任务代码块中，正在等待某个资源，而这个资源没到，但此时执行shutdownNow()，会出现什么情况？

答：当执行shutdownNow()方法时，如遇已经激活的任务，并且处于阻塞状态时，shutdownNow()会执行1次中断阻塞的操作，此时对应的线程报InterruptedException，如果后续还要等待某个资源，则按正常逻辑等待某个资源的到达。例如，一个线程正在sleep状态中，此时执行shutdownNow()，它向该线程发起interrupt()请求，而sleep()方法遇到有interrupt()请求时，会抛出InterruptedException()，并继续往下执行。在这里要提醒注意的是，在激活的任务中，如果有多个sleep(),该方法只会中断第一个sleep()，而后面的仍然按照正常的执行逻辑进行。


源码
```
    ExecutorService executorService = Executors.newFixedThreadPool(5);
    long start = System.currentTimeMillis();
    for (int i=0; i< 10; i ++) {
      int finalI = i;
      executorService.submit(() -> {
        long threadStart = System.currentTimeMillis();
        System.out.println(finalI);
        try {
          TimeUnit.SECONDS.sleep(10);
        } catch (InterruptedException e) {
          System.out.println("interrupted");
        }
        long threadEnd = System.currentTimeMillis();
        System.out.println(finalI + "end: " + (threadEnd - threadStart));
      });
    }
    TimeUnit.SECONDS.sleep(1);
    executorService.shutdownNow();
    try {
      executorService.submit(() -> {});
    } catch (Exception e) {
      System.out.println(e.getClass().getSimpleName());
    }
    long end =System.currentTimeMillis();
    System.out.println(end - start);
```
输出

> 0
> 2
> 3
> 4
> 1
> interrupted
> interrupted
> interrupted
> 1end: 1016
> 0end: 1017
> 4end: 1016
> RejectedExecutionException
> 1125
> interrupted
> 2end: 1023
> interrupted
> 3end: 1024

通过输出可以看到，队列中的任务并没有执行，而且正在执行任务的sleep方法被中断，线程中的任务只执行了1秒

## **awaitTermination(long timeout,TimeUnit unit)**

awaitTermination会一直等待，直到线程池状态为TERMINATED或者，等待的时间到达了指定的时间。



源码
```
public Future<?> submit(Runnable task) {
    if (task == null) throw new NullPointerException();
    RunnableFuture<Void> ftask = newTaskFor(task, null);
    execute(ftask);
    return ftask;
}

    /**
     * Executes the given task sometime in the future.  The task
     * may execute in a new thread or in an existing pooled thread.
     *
     * If the task cannot be submitted for execution, either because this
     * executor has been shutdown or because its capacity has been reached,
     * the task is handled by the current {@code RejectedExecutionHandler}.
     *
     * @param command the task to execute
     * @throws RejectedExecutionException at discretion of
     *         {@code RejectedExecutionHandler}, if the task
     *         cannot be accepted for execution
     * @throws NullPointerException if {@code command} is null
     */
    public void execute(Runnable command) {
        if (command == null)
            throw new NullPointerException();
        /*
         * Proceed in 3 steps:
         *
         * 1. If fewer than corePoolSize threads are running, try to
         * start a new thread with the given command as its first
         * task.  The call to addWorker atomically checks runState and
         * workerCount, and so prevents false alarms that would add
         * threads when it shouldn't, by returning false.
         *
         * 2. If a task can be successfully queued, then we still need
         * to double-check whether we should have added a thread
         * (because existing ones died since last checking) or that
         * the pool shut down since entry into this method. So we
         * recheck state and if necessary roll back the enqueuing if
         * stopped, or start a new thread if there are none.
         *
         * 3. If we cannot queue task, then we try to add a new
         * thread.  If it fails, we know we are shut down or saturated
         * and so reject the task.
         */
        int c = ctl.get();
        if (workerCountOf(c) < corePoolSize) {
            if (addWorker(command, true))
                return;
            c = ctl.get();
        }
        if (isRunning(c) && workQueue.offer(command)) {
            int recheck = ctl.get();
            if (! isRunning(recheck) && remove(command))
                reject(command);
            else if (workerCountOf(recheck) == 0)
                addWorker(null, false);
        }
        else if (!addWorker(command, false))
            reject(command);
    }
```

第一步判断工作线程数量是否小于corePoolSize，如果小于就创建一个新的工作线程

```
int c = ctl.get();
if (workerCountOf(c) < corePoolSize) {
  if (addWorker(command, true))
      return;
  c = ctl.get();
}
```

如果线程池创建成功，直接返回，否则想第二步执行

第二步尝试将任务入队，入队的前提条件线程池还在运行

```
        if (isRunning(c) && workQueue.offer(command)) {
            int recheck = ctl.get();
            if (! isRunning(recheck) && remove(command))
                reject(command);
            else if (workerCountOf(recheck) == 0)
                addWorker(null, false);
        }
```

