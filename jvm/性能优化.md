# 操作系统性能监控
## CPU使用率
要使应用的性能或扩展性达到最高，就必须充分利用分配给它的CPU周期，不能有丝毫浪费。
应用消耗很多CPU并不意味着性能或者扩展性达到了最高。
大多数操作系统的CPU使用率分为用户态CPU使用率和系统态CPU使用率。用户态CPU使用率是指执行应用程序代码的时间占总CPU时间的百分比。
系统态CPU使用率是指应用执行操作系统调用的时间占总CPU时间的百分比。系统态CPU使用率高意味着共享资源有竞争或者I/O设备之间有大量交互。
既然原本用于执行操作系统内核调用的CPU周期也可以用来执行应用代码，所以理想情况下，应用达到最高性能和扩展性时，它的系统态CPU使用率为0%。
所以提高应用性能和扩展性的一个目标是尽可能降低系统态CPU使用率。

对于计算密集型应用来说，不仅要监控用户态和系统态CPU使用率，还要进一步监控每时钟指令数或每指令时钟周期等指标。
即便CPU在等待内存中的数据，操作系统工具仍然会报告CPU繁忙。这种情况通常被称为停滞。当CPU执行指令而所用的操作数据不再寄存器或缓存中时，就会发生停滞。
由于指令执行前必须等待数据从内存装入CPU寄存器，所以一旦发生停滞，就会浪费时钟周期。
**提高计算密集型应用性能的策略就是减少停滞或者改善CPU高速缓存使用率，从而减少CPU在等待内存数据时浪费的适中周期**

### Windows
任务管理器

性能监视器 > Processor > User Time | Privileged Time

typeperf "\Processor(_Total)\% Privileged Time" "\Processor(_Total)\% User Time"

### Linux
vmstat

    procs -----------memory---------- ---swap-- -----io---- -system-- -----cpu------
     r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
     1  0   2824  14128 270900 320872    0    0     0     2   16   10  0  0 99  0

    CPU:
    us：非核心层的 CPU 使用状态； sy：核心层所使用的 CPU 状态； id：闲置的状态； wa：等待 I/O 所耗费的 CPU 状态； st：被虚拟机器 (virtual machine) 所盗用的 CPU 使用状态 (2.6.11 以后才支持)

top

## CPU调度程序运行队列
运行队列中就是那些已准备好运行、正等待可用CPU的轻量级进程。如果准备运行的轻量级进程数超过系统所能处理的上限，运行队列就会很长。
运行队列长表明系统负载可能已饱和。系统运行队列长度等于虚拟处理器的个数时，用户不会明显感觉到性能下降。
当运行队列长度达到虚拟处理的4倍或更多时，系统的响应就非常迟缓了。

一般性的知道原则是：如果在很长一段时间里，运行队列的长度一直都超过虚拟机处理器个数的1倍，就需要关注了，只是暂时还不需要立刻采取行动。
如果在很长一段时间里，运行队列的长度达到虚拟处理器个数的3~4倍或更高，则需要立刻引起注意或采取行动。

解决运行队列长有两种方法。一种是增加CPU以分担负载或减少处理器的负载量。另一种方法是分析系统中运行的应用，改进CPU使用率。
换句话说，研究可以减少应用运行所需CPU周期的方法，如减少垃圾收集的频度或采用完成同样认为但CPU指令更少的算法。

### Windows
性能监视器 > System > Processor Queue Length

typeperf "\System\Processor Queue Length"

### Linux
vmstat

    procs -----------memory---------- ---swap-- -----io---- -system-- -----cpu------
     r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
     1  0   2824  14128 270900 320872    0    0     0     2   16   10  0  0 99  0

    内存栏位 (procs) 的项目分别为：
    r ：等待运行中的程序数量；b：不可被唤醒的程序数量。这两个项目越多，代表系统越忙碌 (因为系统太忙，所以很多程序就无法被运行或一直在等待而无法被唤醒之故)。

## 内存使用率
系统在进行页面交换或使用虚拟内存时，Java应用或JVM会表现出明显的性能问题。当应用所需的内存超过可用物理内存时，就会发生页面交换。
为了应对这种可能的情况，通常要为系统配置swap空间。swap空间一般会在一个独立的磁盘分区上。
当应用耗尽物理内存时，操作系统会将应用的一部分置换到硬盘上的swap空间，通常是应用中最少运行的部分，以免影响整个应用或者应用最忙的部分。
当范围应用中被置换出去的部分时，就必须将它从磁盘置换进内存，而这种置换活动会对应用的响应性和吞吐量造成很大影响。

JVM垃圾收集器在系统页面交换时的性能也很差，这是由于垃圾收集器为了回收不可达对象锁占用的空间，需要访问大量的内存。
如果java堆的一部分被置换出去，就必须先置换进内存以便垃圾收集器扫描存活对象，这会增加垃圾收集的持续时间。
垃圾收集是一种时空停滞操作，即停止所有正在运行的应用线程，如果此时系统正在进行页面交换，则会引起JVM长时间的停顿。

### Windows
性能监视器 > Memory >Pages sec（每秒内存页面调度）| Available MBytes（可用内存字节数） 当可用内存变少，并且有页面调度时，系统可能正在进行页面交换

typeperf -si 5 "Memory\Available Mbytes" "Memory\Pages/sec"

如果可用内存保持恒定，有理由假定没有启动新应用。因为新应用启动时需要将页面换进内存，所以可用内存会下降，同时也能看到页面调度。
所以如果系统使用的内存量保持稳定，也没有启动新应用，却依然有页面调度，说明系统可能正在进行页面交换。

如果系统报告可用内存很少，也没有页面调度，说明系统没有页面交换，只不过系统大部分物理RAM都被占用了。
同样，如果系统在进行页面调度，但内存充足且没有页面交换，说明有应用在启动。

### Linux

vmstat

    procs -----------memory---------- ---swap-- -----io---- -system-- -----cpu------
     r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
     1  0   2824  14128 270900 320872    0    0     0     2   16   10  0  0 99  0

    内存栏位 (memory) 项目分别为：
    swpd：虚拟内存被使用的容量； free：未被使用的内存容量； buff：用於缓冲内存； cache：用於高速缓存。 这部份则与 free 是相同的。

    内存置换空间 (swap) 的项目分别为：
    si：由磁碟中将程序取出的量； so：由於内存不足而将没用到的程序写入到磁碟的 swap 的容量。 如果 si/so 的数值太大，表示内存内的数据常常得在磁碟与主内存之间传来传去，系统效能会很差！

### 监控锁竞争
JAVA+的锁优化机制：线程通过忙循环自旋尝试获得锁，如果若干次忙循环自旋之后仍然没有成功，则挂起该线程，等待被唤醒后再次获取该锁。
挂起和唤醒线程会导致操作系统的让步式上下文切换。因此锁竞争严重的应用会表现出大量的让步式上下文切换。

可以遵循以下的一般性原则，对于任何java应用来说，如果让步式上下文切换占去它5%或更多可用时钟周期，说明它可能遇到了锁竞争，即便只占到3%~5%也值得进一步调查。

Linux下监控：
pidstat -w

### 监控抢占式上下文切换
让步式上下文切换是指执行线程主动放弃CPU，抢占式上下文切换是指线程因为分配的时间片用尽而被迫放弃CPU或者被其他优先级更高的线程所抢占。

### 监控线程迁移
待运行线程在处理器之间的迁移也会导致性能下降。大多数操作系统的CPU调度程序会将待运行线程分配给上次运行它的虚拟处理器。
如果这个虚拟处理器忙，调度程序就会将待运行线程迁移到其他可用的虚拟处理器。
线程迁移会对应用性能造成影响，这是因为新的虚拟处理器缓存中可能没有待运行线程所需的数据或状态信息。
一般性准则是，如果横跨多核或虚拟处理器的Java应用每秒迁移超过500次，将Java应用绑定在处理器组上就有益处。

## 网络I/O使用率
分布式Java应用的性能和扩展性受限于网络带宽或网络I/O的性能。
如果发送到系统网络接口硬件的消息量超过了它的处理能力，消息就会进入操作系统的缓冲区，这会导致应用延迟。此外网络上发生的其他状况也会导致延迟。

### Linux
netstat

nicstat

### Windows
性能监控器 > Network Interface > Bytes Total/sec(网络接口每秒传递的字节数) | Current Bandwidth（网络接口的带宽）

单次读写量小二网络读写量大的应用会消耗大量的系统态CPU，产生大量的系统调用。对于这类应用，减少系统态CPU的策略是减少网络读写的系统调用。
此外，使用非阻塞的NIO，减少处理请求和发送响应的线程数，也可以改善应用性能。

从非阻塞socket读取数据的策略是，应用在每次读请求时尽可能多地读取数据。同样，当往socket中写数据时，每个写调用应该尽可能多地写。

## 磁盘I/O使用率
对于有磁盘操作的应用来说，查找性能问题，就应该监控磁盘I/O。
#### Linux
iostat


# JVM概览
HotSpot VM有3个主要组件：VM运行时（Runtime）、JIT编译器（JIT Compiler）以及内存管理器（Memory Manager）

TODO

# JVM性能监控
## 垃圾收集
监控JVM的垃圾收集非常重要，因为它对应用的吞吐量和延迟有着深刻的影响。
### 重要的垃圾收集数据

- 当前使用的垃圾收集器
- java堆的大小
- 新生代和老年代的大小
- 永久代的大小
- Minor GC的持续时间
- Minor GC的频率
- Minor GC的空间回收量
- Full GC的持续时间
- Full GC的频率
- 每个并发垃圾收集周期内的空间回收量
- 垃圾收集前后java堆的占用量
- 垃圾收集前后新生代和老年代的占用量
- 垃圾收集前后永久代的占用量
- 是否老年代或永久代的占用触发了Full GC
- 应用是否显示调用了System.gc()

### 垃圾收集报告
HotSpot VM报告垃圾收集数据几乎没有什么额外开销，建议在生产环境中使用。

一般来说，垃圾收集分为两种：Minor GC和Full GC。Minor GC收集新生代，Full GC通常会收集整个堆，包括新生代、老年代和永久代，
除了将新生代的活跃对象提升到老年代之外，还会压缩整理老年代和永久代。因而Full GC之后，新生代为空，老年代和永久代也已压缩整理并且只有活跃对象。

Minor GC会释放新生代中不可达对象所占的内存。Full GC会释放新生代、老年代和永久代中不可达对象所占的内存。
开启-XX:+UseParallelGC或-XX:+UseParallelOldGC时，如果关闭-XX:-ScavengeBeforeFullGC，HotSpot VM在Full GC之前不会进行Minor GC；
如果开启-XX:+ScavengeBeforeFullGC,HotSpot VM会在Full GC前先做一次Minor GC,分担一部分Full GC原本要做的工作，
在这两次独立的GC之间Java线程有机会得以运行，从而缩短最大停顿时间，但也拉长了整体的停顿时间。

-XX:+PrintGCDetails

-verbose:gc可能是报告垃圾收集信息最常用的命令行选项，而-XX:+PrintGCDetails可以打印更有价值的垃圾收集信息。

-XX:+UseConcMarkSweepGC 使用CMS收集器

-XX:+PrintGCTimeStamps 在日志中输出自JVM启动以来到垃圾收集之间流逝的秒数

-XX:+PrintGCDateStamps 生成符合ISO8601标准的时间戳

时间戳可以让你计算Minor GC和Full GC实际的持续时间和频率，也能推算它们的预期值，如果不符合应用需求，可以调优。

-Xloggc:<filename> 将垃圾收集的统计数据直接输出到文件，以便离线分析

-XX:+PrintGCApplicationConcurrentTime和-XX:+PrintGCApplicationStoppedTime HotSpot VM可以报告应用在安全点操作之间的运行时间，以及阻塞java线程的时间。
利用这两个命令行选项观察安全点操作有助于理解和量化延迟对JVM的影响，也可以用来辨别是JVM安全点操作还是应用程序引入的延迟。

## JIT编译器
虽然JIT编译器加快了应用的运行，但它也需要计算资源，如CPU周期和内存。
当你想找出哪些方法被优化，或某些情况下的逆优化或重新优化时，监控JIT编译就有用了。
JIT编译器优化时会有以下初始假设，如果之后发现不正确，就可能会发生逆优化有着重新优化。
这种情况下，JIT编译器会防区之前所做的优化而基于获得的新信息重新优化。

-XX:+PrintCompilation 为每次编译生成一行日志

## 类加载
JVM类加载器负责加载类，也负责卸载类。何时加载或卸载类取决于JVM运行时环境和所用的类加载器。

HotSpot VM会把所有类的元数据信息都加载到永久代。当永久代满时，就会发生垃圾收集。
因此，监视类加载活动和永久代的使用，对于应用性能能否满足需求是有重要意义的，另外垃圾收集的统计数据也可以指明类是何时从永久代卸载的。

当需要加载其他类而空间不足时，未使用的类就会从永久代中被卸载。
从永久代卸载类，意味着需要Full GC，而呈现可能会因此遭遇性能问题。
Full GC过程中的类卸载，说明永久代需要扩大，或者它的初始值需要扩大

-XX:PermSize 永久代的初始大小

-XX:MaxPermSize 永久代的最大值

为避免FullGC扩大或缩小永久代的可分配空间，可以设置-XX:PermSize和-XX:MaxPermSize为相同值。
如果永久代开启并发垃圾收集，你可能会在永久代并发垃圾收集周期中看到类被卸载。
永久代并发垃圾收集周期并不是Stop-The-World，所以应用不会感受到垃圾收集导致的停顿。
并发永久代垃圾收集只能和并发收集器CMS一起使用。

## Java应用监控

### 快速监控锁竞争
jstack抓取线程转储信息

锁地址是锁在jstack日志中的唯一标识。如果栈追踪信息的锁地址不同，说明是不同的锁。
在jstack日志中查找锁竞争的关键在于，从多个线程的栈追踪信息中查找相同的锁地址，然后找到等待该锁的线程。
如果发现多个线程的栈追踪信息都试图锁住相同的锁地址，说明应用正面临锁竞争。
抓取多份jstack日志，如果在同一个锁上一种出现类似的锁竞争，那么应用极有可能正面临高度锁竞争问题。

#Java应用性能分析
performance analyzer

NetBeans Profiler

TODO

# Java应用性能分析技巧
## 性能优化机会
大多数的java性能优化都可以归纳到下面几类:

- 更高效的算法
- 减少锁争用
- 为算法生成更有效率的代码

## 系统或内核态CPU使用
如果CPU始终周期被永远执行操作系统或内核代码，这部分始终周期就无法永远执行应用程序。
因此改善应用程序性能的策略之一就是减少消耗在系统或内核CPU上的时钟周期数。
但是这一策略不适用于在系统或内核态上消耗时间极少的应用程序。

## 锁竞争
运行在现代JVM上的应用程序发生锁竞争时，症状常常是扩展性不好，无法利用更多的工作线程和CPU处理更多的用户。
找到锁竞争的源头，即在源代码中找到哪些Java Monitor对象触发了竞争，并设法减少这些竞争是一件极具挑战的工作。

如果存在对原子变量高度竞争的情况，即使采用了并发技术或lock-free数据结构也不能避免糟糕的性能或伸缩性。

JAVA SE中有很多原子并发数据结构，在适当的场合，它们都是处理并发的不错选择。
但是当合适的数据结构不存在时，还有另一个选择，那就是通过恰当的方法，合理设计应用程序，
尽量降低多线程访问同一数据的频率，缩小并发访问的范围。
换句话说，通过优化程序设计，最大程度低减少数据的同步访问（区间、大小或数据量）

## volatile的使用
对一个拥有多个CPU缓存，性能要求很高的应用程序，**频繁更新**volatile字段可能导致性能问题。

## 调整数据结构的大小
### StringBuilder和StringBuffer大小的调整
如果StringBuilder和StringBuffer扩大到超过了底层数据的存储能力时，就需要为它分配新的数组。
### Java Collection类大小调整

## 增加并行性

## 过高的CPU使用率

# JVM调优入门
## 方法
1. 划分应用程序的系统需求优先级
2. 选择JVM部署模式
3. 选择JVM运行时
4. 确定并调优应用程序内存使用
5.确定并调优应用程序延迟
6.确定并调优应用程序吞吐量

## 应用程序的系统需求
### 可用性
可用性是对应用程序处于可操作、可使用状态的度量。
可用性需求指的是当应用程序的某些组件发生故障或失效时，应用程序或应用程序的一部分在多大程度上还可以继续提供服务。

Java应用程序的上下文中，利用应用程序组件化，在多个JVM中运行或在多个JVM上运行多个应用程序实例都可以实现高可用性。

高可用性需求的一个典型例子是，应用程序的部署应该确保即使软件组件发生了不可意料的失效，也不会导致整个程序无法使用。

### 可管理性
可管理性是对由运行、监控应用程序而产生的操作性开销的度量，同时也包含了配置应用程序的难易程度。
可管理性需求用于衡量系统管理的难易程度。一般来说，应用程序使用的JVM数量越少，运行、监控应用程序的运营成本越低。
与此同时，使用的JVM数目越少，配置也越容易，然后这将会牺牲应用程序的可用性。

可管理型需求的一个典型例子是，由于人力资源有限，应用程序的部署需要尽量减少JVM的使用数量。

### 吞吐量
吞吐量是对单位时间内处理工作量的度量。设计吞吐量需求时，我们一般不考虑它对延迟或者响应时间的影响。
通常情况下，增加吞吐量的代价是延迟的增加或内存使用的增加。

吞吐量性能需求的一个典型例子是，应用程序每秒需要完成2500次事务。

### 延迟及响应性
延迟，或者响应性，是对应用程序收到指令开始工作直到完成该工作所消耗时间的度量。
定义延迟或响应性需求时并不考虑程序的吞吐量。通常情况下，提高响应性或缩小延迟的代价是更低的吞吐量、或更多的内存消耗。

延迟或响应性需求的一个典型例子是，应用程序应该在60毫秒内完成交易请求的处理工作。

### 内存占用
内存占用指在同等程度的吞吐量、延迟、可用性和可管理性前提下，运行应用程序锁需的内存大小。
内存占用通常以运行应用程序需要的Java堆大小或者运行应用程序需要的总内存大小来表述。
一般情况下，通过增大Java堆的方式增加可用内存能够提高吞吐量、降低延迟或者兼顾二者。
应用程序的可用内存减少时，吞吐量和延迟通常都会受到影响。
应用程序的内存占用限制了固定内存的机器上能同时运行的应用程序实例数。

内存占用需求的一个典型例子是，应用程序需要在拥有8GB内存的系统上以单个实例方式运行或者在24GB内存系统上以3个实例方式运行。

### 启动时间
启动时间是指应用程序初始化所消耗的时间。此外，Java应用程序中另一个值得关注的指标是现代JVM完成应用程序热区优化，初始化锁消耗的时间。
Java应用程序初始化的完成时间取决于很多因素，包括：初始化时载入的类的数量、需要初始化的对象的数量、这些对象如何初始化
以及HotSpot VM的运行时环境的选择，即Client模式还是Server模式。

启动时间需求的一个典型例子是，应用程序的初始化需要在15秒内完成。

## 对系统需求分级
调优过程的第一步是划分应用程序的系统需求优先级。

## 选择JVM部署模式
### 单JVM部署模式
### 多JVM部署模式

## 选择JVM运行模式
### Client模式或Server模式
-server -XX:+TieredCompilation 开启Tiered Server模式，它结合了Client和Server运行模式的长处：即快速启动和高效的生成码。

### 32位/64位JVM
-d64 -XX:+UseCompressedOops或-d64（大于32GB）

### 垃圾收集器
-XX:+UseParallelOldGC 同时启用多线程的新生代垃圾收集器和多线程的老年代垃圾收集器（Parallel Scavenge + Parallel Old），它会自动启动-XX:+UseParallelGC选项
-XX:+UseParallelGC 仅启用多线程的新生代垃圾收集器，老年代垃圾收集器仍然采用单线程（Parallel Scavenge + Serial Old）
-XX:+UseConcMarkSweepGC 使用ParNew + CMS + Serial Old，Serial Old作为CMS出现Concurrent Mode Failure失败后的后备收集器使用
-XX:+UseSerialGC 使用Serial + Serial Old
-XX:+UseParNewGC 使用ParNew + Serial Old

## 垃圾收集调优基础
### 性能属性
吞吐量：指不考虑垃圾收集引起的停顿时间或内存消耗，垃圾收集器能支撑应用程序达到的最高性能指标。

延迟：度量标准是缩短由于垃圾收集引起的停顿时间或完全消除因垃圾收集所引起的停顿，避免应用程序运行时发生抖动

内存占用：垃圾收集器流畅运行所需要的内存数量

这其中任何一个属性性能的提高几乎都是以另一个或两个属性性能的损失做代价的。

### 原则
“Minor GC回收原则”：每次Minor GC都尽可能多地收集垃圾对象。遵守这一原则可以减少应用程序发生Full GC的频率。

“GC内存最大化原则”：处理吞吐量和延迟问题时，垃圾处理器使用的内存越大，即Java堆空间越大，垃圾收集器的效果越好，应用程序运行也越流畅。

“GC调优的3选2原则”：吞吐量、延迟、内存占用三个性能属性中任意选择两个进行JVM垃圾收集器调优。

### GC日志和命令

-XX:+PrintGCDetails

-XX:+PrintGCTimeStamps 在日志中输出自JVM启动以来到垃圾收集之间流逝的秒数

-XX:+PrintGCDateStamps 生成符合ISO8601标准的时间戳

时间戳可以让你计算Minor GC和Full GC实际的持续时间和频率，也能推算它们的预期值，如果不符合应用需求，可以调优。

-Xloggc:<filename> 将垃圾收集的统计数据直接输出到文件，以便离线分析



-XX:+PrintGCApplicationConcurrentTime、-XX:+PrintGCApplicationStoppedTime、+XX:+PrintSafepointStatistics
用于调优响应时间/延迟较高的应用程序，可以帮助区分是VM的安全点操作还是其他源头导致的停顿事件。
HotSpot VM可以报告应用在安全点操作之间的运行时间，以及阻塞java线程的时间。
利用这两个命令行选项观察安全点操作有助于理解和量化延迟对JVM的影响，也可以用来辨别是JVM安全点操作还是应用程序引入的延迟。

## 确定内存占用
### 约束
JVM可以使用的物理内存量。
### 堆内存分配
-Xms 堆内存的初始值和最小值

-Xmx 堆内存的最大值

关注吞吐量及延迟的Java应用程序要将-Xms和-Xmx设为同一值。这是因为无论扩展还是缩减堆内存都需要进行Full GC，而Full GC会降低程序的吞吐量并导致更长的延迟。

-XX:NewSize=<n>[g|m|k] 新生代空间大小的初始值，也是最小值，和-XX:MaxNewSize一起使用

-XX:MaxNewSize=<n>[g|m|k] 新生代空间大小的最大值，和-XX:NewSize一起使用

-Xmn<n>[g|m|k] 设置新生代空间的初始值，最小以及最大值。硬性规定新生代空间的大小，如果-Xms和-Xmx并没有设定为同一个值，使用-Xmn选项时，
Java堆的大小变化不会影响新生代空间，即新生代空间的大小总是保持恒定，而不是随着Java堆大小的扩展或缩减做相应的调整。
因此只有在-Xms和-Xmx设定为同一值时踩使用-Xmn选项。

老年代空间的大小会根据新生代的大小隐式设定。老年代空间的初始值 = -Xmx的值 - -XX:NewSize的值。
老年代空间的最小值 = -Xmx的值 - -XX:MaxNewSize的值。
如果-Xms与-Xmx设置为同一值，同时使用了-Xmn,或者-XX:NewSize与-XX:MaxNewSize一样，则老年代的大小 = -Xmx的值 - -Xmn

-XX:NewRatio=<ratio> 新生代和老年代的比例，默认值2，即1:2

-XX:SurvivorRatio=<ratio> Eden与单个Survivor的比例，默认32

-XX:PretenureSizeThreshold 大于这个值的对象直接在老年代中分配

永生代空间大小

-XX:PerSize=<n>[g|m|k] 永生代空间的初始值及最小值
-XX:MaxPerSize=<n>[g|m|k] 永生带空间的最大值

开启-XX:+UseParallelGC或-XX:+UseParallelOldGC时，如果关闭-XX:-ScavengeBeforeFullGC，HotSpot VM在Full GC之前不会进行Minor GC,
但Full GC过程中依然会收集新生代。

### 堆大小调优
-XX:+PrintCommandLineFlags 查看堆的初始值及最大值

### 计算活跃数据大小
活跃数据大小是应用程序运行与稳定态时，长期存活的对象在Java堆中占用的空间大小。

堆大小计算法则

Java堆：3~4倍Full GC后老年代空间占用量

永久代： 1.2~1.5倍Full GC后的永久代空间占用量

新生代：1~1.5倍Full GC后老年代空间占用量

老年代：2~3倍 Full GC后永久代空间占用量

## 调优延迟/响应性
优化Java堆大小的配置、评估GC的持续时间和频率、是否可能切换到不同的垃圾收集器以及发生垃圾收集器切换之后进一步的内存调优

### 优化新生代大小
根据垃圾收集的统计数据、Minor GC的持续时间和频率可以确定新生代空间的大小。通常情况下，新生代空间越小，Minor GC持续的时间越短。
减少新生代空间又会增大Minor GC的频率。

分析GC数据时，如果发现Minor GC的间隔过长，修正的方法是减少新生代空间。如果Minor GC的频率太高，修正的方法是增加新生代空间。

如果观察到平均GC持续时间大于应用程序的延迟性要求，可以适当减小新生代空间的大小，之后再运行测试。
如果观察到Minor GC的频率大于应用程序的延迟性要求，增大新生代空间，之后再运行测试。

### 优化老年代的大小
评估Full GC引入的最差停滞时间以及Full GC的频率。
发生稳定态的Full GC的持续时间是应用程序的最差Full GC停滞时间。

### Survivor空间

-XX:NewRatio=<ratio> 新生代和老年代的比例，默认值2，即1:2

-XX:SurvivorRatio=<ratio> Eden与单个Survivor的比例，默认32

survivor空间的大小 = -Xmn<value>/(-XX:SurvivorRatio=<ratio> + 2)

对于给定的新生代，减少Survivor的比率会增大Survivor空间，同时减少Eden空间。
减少Eden空间会导致更频繁的Minor GC，反之，增大Eden空间可以减少Minor GC的频率。
垃圾收集发生的频率越高，对象老化的速度就越快

### 晋升阈值
“晋升”意味着对象提升至老年代空间。
HotSpot VM在每次Minor GC时都会计算晋升阈值以决定什么时候对一个对象进行提升。
晋升阈值就是对象的年龄。一个对象的年龄就是它所经历的Minor GC次数。
对象首次分布时，它的年龄为0，下一次Minor GC之后，如果该对象还在新生代，其年龄变为1。
如果它在第二次Minor GC之后又存活下来，它的年龄变为2，以此类推。
新生代空间中年龄大于HotSpot VM计算出的晋升阈值的对象都会被提升到老年代空间。

晋升阈值计算的依据是Minor GC之后新生代要容纳的可达对象需要的空间大小以及目标Survivor空间占用的大小。
CMS使用的新生代垃圾收集器(ParNew收集器)会计算晋升阈值。

-XX:MaxTenuringThreshold=<n> 指定HotSpot VM在对象的年龄超过<n>值时将其提升到老年代空间。
内部计算出的晋升阈值不会超过最大晋升阈值。JDK5U6之后最大晋升阈值可以设置在0~15之间。

当目标Survivor空间的占用等于或小于HotSpot VM期望维护的值时，HotSpot VM将使用最大晋升阈值作为其计算出的晋升阈值。
如果HotSpot VM任务它无法维护Survivor空间的占用，它会使用一个低于最大值的晋升阈值来保证目标survivor空间的占用。
比晋升阈值年龄大的对象都会被提升到老年代。
当存活下来的空间占用的空间超过目标survivor空间的容量时就会发生溢出。
溢出会导致对象被迅速提升至老年代，造成老年代的增长也远快于预期，而这又会引起CMS被频繁调用，降低应用程序的吞吐量，增大了出现碎片的可能性。
所有这些可能导致更频繁的Stop-The-World压缩式垃圾收集。

发生溢出的情况下，需要提升哪些对象，应该根据其实际年龄与晋升阈值进行比较。超过晋升阈值的对象才可以提升进入老年代。
因此，监控晋升阈值对避免survivor空间溢出是件非常重要的任务。

### 监控晋升阈值
-XX:+PrintTenuringDistribution 可以监控晋升的分布或者对象年龄分布，并以此为依据确定最优的最大晋升阈值。

通过-XX:+PrintTenuringDistribution可以观察survivor空间的对象是如何老化的。
在-XX:+PrintTenuringDistribution生成的输出中，我们需要关注的是随着对象年龄的增加，各对象年龄上字节数减少的情况，
以及HotSpot VM计算出的晋升阈值是否等于或者接近设置的最大晋升阈值。

-XX:+PrintTenuringDistribution会输出每次Minor GC时晋升分布的情况，它可以和其他垃圾收集命令行选项配合使用。
对survivor空间的有效对象老化进行微调时，应该使用-XX:+PrintTenuringDistribution在垃圾收集日志中包含晋升分布的统计信息。
同样，如果需要在生产环境中判断一个应用程序事件是否源于一次Stop-The-World压缩式垃圾收集，往往也需要获取晋升分布的日志信息。

通常情况下，观察到新的晋升阈值持续小于最大晋升阈值，或者观察到survivor空间大小小于总的存活对象大小（即对象年龄最后最右列的值）都表明survivor空间过小。

### 调整survivor空间的容量
调整survivor空间容量时，如果新生代空间大小不变，增大survivor空间会减少Eden空间；而减少survivor空间会减少Eden空间；
而减少Eden空间会增加Minor GC的频率。因此为了同时满足应用程序Minor GC频率的要求，就需要增大当前新生代空间的大小；
即增大survivor空间大小时，Eden空间的大小应该保持不变。换句话说，每当survivor空间增加时，新生代空间都应该增大。
如果可以增大Minor GC的频率，你可以选择用一部分Eden空间来增大survivor空间，或者直接增大新生代空间大小。
如果内存足够，相对于减少Eden空间，增加新生代大小通常是更好的选择，保持Eden空间大小恒定，Minor GC的频率就不会由于survivor空间增大而发生变化。

使用CMS时，任何提升到老年代空间并最终被垃圾收集的对象都会增加内存碎片，或者导致Stop-The-World压缩式垃圾收集。
通常情况下，即使在Survivor空间之间多次复制对象也比匆匆将对象提升到老年代要好。

**调优目标Survivor空间占用**
目标survivor空间占用是HotSpotVM尝试在Minor GC之后仍然维持的Survivor空间占用。通过-XX:TargetSurvivorRatio=<percent>可以对该值进行调整。默认值是50.

**初始化CMS收集周期**
一旦包含Eden空间和survivor空间在内的新生代空间优化完成，Minor GC引入的延迟达到应用程序的要求之后，
我们可以把精力转向CMS收集器的调优上，减小最差情况的延迟并最小化最差延迟发送的频率。
这一步的目标是维持空闲老年代空间的恒定，并由此避免发生Stop-The-World压缩式垃圾收集。

Stop-The-World压缩式垃圾收集是引入延迟的最大的垃圾收集。

成功的CMS收集器调优要能以对象从新生代提升到老年代的同等速度对老年代中的对象晋升垃圾收集。达不到这个标准则称之为“失速”
失速的结果就会发生Stop-The-World压缩式垃圾收集。避免失速的关键是要结合足够大的老年代空间和足够快地初始化CMS垃圾收集周期，让它以比提升速率更快的速度回收空间。

CMS周期的初始化基于老年代空间的占用情况。如果CMS周期开始得太晚，就会发生失速。如果它无法以足够块的速度回收对象，就无法避免老年代空间用尽。
但是CMS周期开始得过早，又会引起无用的消耗，影响应用程序的吞吐量。通常早启动CMS周期要比晚启动CMS好，因为启动太晚的结果比启动过早的结果要恶劣得多。

如果你碰到Stop-The-World压缩式垃圾收集，可以尝试调节CMS周期启动的时间。
CMS中发生的Stop-The-World压缩式垃圾收集在垃圾收集日志中可以通过查找并发模式失效(Concurrent Mode Failure)定位。

如果你在垃圾收集日志中发现concurrent mode failure字样，可以通过 -XX:CMSInitiatingOccupancyFraction=<percent> 通知HotSpot在更早的时间启动CMS垃圾收集周期。

-XX:CMSInitiatingOccupancyFraction=<percent> 设置CMS垃圾收集周期在老年代空间占用达到多少百分比时启动。

-XX:+UseCMSInitiatingOccupancyOnly 总是使用-XX:CMSInitiatingOccupancyFraction=<percent>设定的值作为启动CMS周期的老年代空间占用阈值。
不使用-XX:+UseCMSInitiatingOccupancyOnly，HotSpot仅在启动的第一个CMS周期里使用-XX:CMSInitiating-OccupancyFraction设定的值作为占用比率，
之后的周期中又转向自适应地启动CMS周期，即第一次CMS周期之后就不再使用-XX:CMSInitiatingOccupancyFraction设定的值。

-XX:CMSInitiatingOccupancyFraction设定的空间占用值应该大于老年代占用空间和活跃数据大小之比。
应用程序的活跃数据大小就是一次Full GC之后堆所占用的空间大小。
如果使用-XX:CMSInitiatingOccupancyFraction设置的值小于活跃数据的占用百分比，CMS收集器一直运行陷入死循环。
因此-XX:CMSInitiatingOccupancyFraction设置的一个通用原则是老年代占用百分比应该至少是活跃数据大小的1.5倍。

何时启动CMS周期取决于对象从新生代提升至老年代的速率，即老年代空间的增长率。
如果老年代空间消耗得比较慢，可以在稍晚的时候启动CMS周期。如果老年代空间消耗的迅速，你应该在较早的时候启动CMS周期，但是也不应低于活跃数据的占用比率。
不应该将启动CMS周期的值设置得比活跃数据的大小低，解决这个问题更好的方法是增大老年代空间的大小。

### 显式的垃圾收集
使用CMS时，如果你观察到由显示调用System.gc()触发的Full GC，有两种处理的方法。

1. -XX:+ExplicitGCInvokesConcurrent 或 -XX:+ExplicitGCInvokesConcurrentAndUnloadsClasses

2.-XX:+DisableExplicitGC 忽略显式的System.gc()调用

### 并发永久代垃圾收集
Full GC也可能源于永久代空间用尽。观察永久代空间的使用情况就能判断该Full GC是否由永久代空间耗尽所导致。

虽然永久代空间在垃圾收集日志中会以CMS Perm标记出，但是在CMS中，Hotspot VM默认情况下不会对永久代空间进行垃圾回收。

-XX:+CMSClassUnloadingEnabled 开启CMS的永久代垃圾收集，可以与-XX:+CMSPermGenSweepingEnabled一起使用

-XX:CMSInitiatingPermOccupancyFraction=<percent> 在永久代占用百分比达到多少时启动CMS永久代垃圾收集，
需要同时使用-XX:+CMSClassUnloadingEnabled选项，并与-XX:+UseCMSInitiatingOccupancyOnly配合使用

### 调优CMS停顿时间
CMS周期中有两个阶段是Stop-The-World的阶段（初始标记、重新标记），处于这两个阶段的应用程序线程会被阻塞。
虽然初始标记阶段是单线程，却极少占很长的时间，通常情况下远小于其他的垃圾收集停顿。重新标记阶段是多线程的.

-XX:ParallelGCThreads=<n> 重新标记阶段使用的线程数

JDK6U23+，如果Runtime.availableProcessors()的返回值小于等于8，-XX:ParallelGCThreads默认值等于这个值。
否则，该值默认为 8 + Runtime.availableProcessors() * 5 / 8。
多个应用程序运行于同一个系统的场景里，建议将CMS收集线程数设置得小于默认值，否则由于大量的垃圾收集线程同时执行，应用程序的性能会收到极大的影响。

-XX:+CMSScavengeBeforeRemark 强制HotSpot VM在进入CMS重新标记阶段之前先进行一次Minor GC。
重新标记之前的Minor GC通过减少引用老年代空间的新生代对象数目，将重新标记阶段的工作量减到了最少。

如果应用程序有大量的引用对象或可终结对象要处理，使用下面的命令行选项：-XX:+ParallelRefProcEnabled 可以加速引用处理。
它使用多个引用处理线程，但不会启动多个线程去执行方法的终结方法。实际上使用该选项后会启动多个线程去查找需要加入通知队列的终结对象。

## 应用程序吞吐量调优
Java堆可用的内存越多，应用程序的性能越好。这一原则不仅适用于吞吐量的性能，也适用于延迟性能。

可以使用-XX:+UseParallelOldGC 或 -XX:+UseParallelGC选项使用Throughput收集器（HotSpot中通常是Parallel Scavenge收集器）
或者使用CMS

### CMS吞吐量调优

1. TODO
2. 增加新生代空间大小，以降低Minor GC的频率，从而减少固定时间内Minor GC的次数。
3. 增加老年代空间大小，以降低CMS周期的频率并减少内存碎片，最终减少并发模式失效以及Stop-The-Wolrd压缩式垃圾收集发生的几率
4. 优化新生代堆的大小，调整Eden和Survivor空间大小以优化对象老化，减少新生代提升到老年代的对象数目，最终减少CMS周期的发生数。
5. 优化CMS周期的启动条件，尽可能的在较晚的时候进行。在较晚的世界启动CMS周期能够降低CMS周期发生的频率，
但是更晚时候启动CMS的后悔是出现并发模式失效，而且发生Stop-The-World压缩式垃圾收集的几率也会增大。

以上任何一个选项或几个选项的组合都可以减少垃圾收集器消耗的CPU周期数，从而将更多的CPU周期拥有执行应用程序。
对于提高吞吐量，同时又期望不触发Stop-The-World压缩式垃圾收集增大延迟的目标而言，前两个选项是更理想的方法。

一个指导原则是，CMS包括Minor GC所带来的开销应该小于10%。

### Throughput收集器
对于Throughput收集器进行吞吐量性能调优的目标是尽可能避免发生Full GC，或者更理想的情况下载稳定态时永远不发生Ful GC。
为达到这个目标需要优化对象老化频率。通过显示地微调survivor空间可以实现对象老化的优化。
你可以将Eden空间变得更大，从而降低Minor GC的频率，确保老年代有足够的空持有应用程序的活跃数据。
度过对象没有理想的老化频率，一些非长期存活对象被提升到老年代时，可以增加一些额外的老年代空间来应对这种情况。
对象的老化是按照对象经历的Minor GC次数计算的。
假设不发生survivor空间溢出，增大Eden空间可以降低Minor GC发生的频率，同时延长对象老化的时间。

Throughput收集器提供的吞吐量性能是HotSpot VM诸多垃圾收集器中最好的。它默认启用了一个称为自适应大小调整的特性。
自适应大小调整根据对象分配以及存活率自动对新生代的Eden和Survivor空间进行调整以最优化对象老化频率。
禁用自适应大小调整会牺牲改变英勇程序行为的灵活性

-XX:-UseAdaptiveSizePolicy 禁用自适应大小调整。

-XX:+PrintAdaptiveSizePolicy 可以生成更详细的Survivor空间占用日志，无论是survivor空间溢出，还是对象从新生代提升进入老年代统统囊括在内。
通常与-XX:+PrintGCDetails、-XX:+PrintGCDateStamps或-XX:+PrintGCTimeStamps之一配合使用。

### Survivor空间调优
调整Survivor空间的大小的目标是在短期存活对象被提升到老年代空间之前，尽可能长时间地保持/老化这些对象。
我们可以从查看稳定态发生的Minor GC入手，尤其要注意存活的对象大小。
从初始态转入到稳定态，可能需要考虑忽略刚开始的几个Minor GC的数据，因为应用程序在初始化阶段尽可能分配一些长期存在的对象，
这些对象在提升进入老年代之前需要一些老化的时间。对于大多数应用，通常忽略应用程序达到稳定态之前5~10个Minor GC即可。

一个通用原则是使用Throughput收集器时，垃圾收集的开销应该小于5%。

### 调优并行垃圾收集线程
-XX:ParallelGCThreads=<n>

多个应用程序运行与同一系统上设置并行垃圾收集线程的一个通用原则是用虚拟处理器的数目除以该系统运行的应用程序数。

## 其他
### 实验性优化
-XX:+AggressiveOpts引入实验性的优化方法

### 逃逸分析
逃逸分析是一种评估Java对象可见范围的技术。尤其是指由某个执行线程创建的Java对象在另一个线程中可以访问，此时我们称该对象“逃逸”了。
如果Java对象不发生逃逸，可以采用其他方法进行调优。因此这种优化技术被称为逃逸分析。

-XX:+DoEscapeAnalysis 开启逃逸分析优化 JDK6U23+默认开启

### 偏向锁
偏向锁是一种偏向于最后获得对象锁的线程的优化技术。当只有一个线程锁定该对象，没有锁冲突的情况下，其锁开销可以接近lock-free

-XX:+UseBiasedLocking 开启偏向锁 JDK6+默认开启

### 大页面支持
计算机系统的内存被划分为称为“页”的固定大小的块。程序访问内存的过程中会将虚拟内存地址转换成物理内存地址。
虚拟地址到物理地址的转换是通过页表完成的。为了减少每次内存访问时访问页表的代价，通常的做法是使用一块快速缓存，对虚拟地址到物理地址的转换进行缓存。
这块缓存被称为转译快查缓存（TLB）

-XX:+UseLargePages 开启大页面支持，需要操作系统支持。

# Java应用的基准测试
## 基准测试面临的挑战
### 基准测试的预热阶段
执行基准测试时使用-XX:+PrintCompilation，可以判断JIT编译器何时完成了预热阶段，确保在HotSpot JIT编译器到达稳定态后，即已经完成它的优化工作后再开始基准数据采样。
对于基准测试而言，目标是在日志中不再出现-XX:+PrintCompilation相关的日志之后才开始采样基准数据。

### 垃圾收集
垃圾收集引起的停顿造成的影响

### 使用Java Time接口

### 剔除无效代码

### 内联

### 逆优化

# Web应用的性能调优



