## 判断一个ASCII字符组成的字符串里面没有重复字符，**且不能使用额外的数据结构**

> **ASCII码**占用一个字节，可以**有**0～255共256个取值。 前128个为常用的字符如运算符，字母 ，数字等 键盘上可以显示的后 128个为 特殊字符是键盘上找不到的字符

方案1是采用hash的方式，就是准备一个256个bit的数组，然后将ASCII码的每一个符号都对应到这个数组的某个位置，但是这种方式并不是对空间占用更优的方式。（和HASH其实同一种解法）

> 将每一个字符hash 到一个哈希表中， 检查这个字符是否已经存在， 如果位置处为1， 表示已经存在。
>
> 这个方式的时间复杂度为O(n)

为了找的对空间再用更优的方案，我们先来看一下将问题的范围缩小

## 如何判断一个只包含a-z的字符串里面没有重复字符

这个算法看了好久才整明白，泪奔

a-z只有26个字符，使用bitmap可以用一个int完全包括

首先声明一个int变量checker作为bitmap，初始为0，对应的二进制为0

第一步：将1左移`char - 'a'`个bit，得到的二进制永远是`1000000....000`这种格式，26个字符唯一的那个1都位于不同的位置。将这26个数字做&计算得到的永远是0

第二步: 将checker与第一步得到的数组进行位与&计算，如果最后得到的结果大于0，就说明对应的bit位置为1，字符重复。如果字符不重复就在通过位或|计算，将对应的bit位置设为1。

```
public class IsUniqueChars {
    public boolean isUniqueChars(String str) {
        int checker = 0;
        for(int i = 0; i < str.length(); i++) {
            int val = str.charAt(i) - 'a';
            if((checker & (1 << val)) > 0) {
                return false;
            }
            checker |= (1 << val);
        }
        return true;
    }
}
```

网上找的的一个详细解说



```
public static void main(String[] args) {
        System.out.println(isUniqueChars("abcdmc")); // false
        System.out.println(isUniqueChars("abcdm")); // true
        System.out.println(isUniqueChars("abcdm\u0061")); // false because \u0061 is unicode a
    }


    public static boolean isUniqueChars(String str) {
        /*
         You should first ask your interviewer if the string is an ASCII string or a Unicode string.
         Asking this question will show an eye for detail and a solid foundation in computer science.
         We'll assume for simplicity the character set is ASCII.
         If this assumption is not valid, we would need to increase the storage size.
         */
        // at 6th edition of the book, there is no pre condition on string's length
        /*
         We can reduce our space usage by a factor of eight by using a bit vector.
         We will assume, in the below code, that the string only uses the lowercase letters a through z.
         This will allow us to use just a single int.
          */
        // printing header to provide nice csv format log, you may uncomment
//        System.out.println("char,val,valBinaryString,leftShift,leftShiftBinaryString,checker");
        int checker = 0;
        for (int i = 0; i < str.length(); i++) {
            /*
                Dec Binary Character
                97  01100001    a
                98  01100010    b
                99  01100011    c
                100 01100100    d
                101 01100101    e
                102 01100110    f
                103 01100111    g
                104 01101000    h
                105 01101001    i
                106 01101010    j
                107 01101011    k
                108 01101100    l
                109 01101101    m
                110 01101110    n
                111 01101111    o
                112 01110000    p
                113 01110001    q
                114 01110010    r
                115 01110011    s
                116 01110100    t
                117 01110101    u
                118 01110110    v
                119 01110111    w
                120 01111000    x
                121 01111001    y
                122 01111010    z
             */
            // a = 97 as you can see in ASCII table above
            // set val to be the difference between the char at i and 'a'
            // b = 1, d = 3.. z = 25
            char c = str.charAt(i);
            int val = c - 'a';
            // means "shift 1 val numbers places to the left"
            // for example; if str.charAt(i) is "m", which is the 13th letter, 109 (g in ASCII) minus 97 equals 12
            // it returns 1 and 12 zeros = 1000000000000 (which is also the number 4096)
            int leftShift = 1 << val;
            /*
                An integer is represented as a sequence of bits in memory.
                For interaction with humans, the computer has to display it as decimal digits, but all the calculations
                are carried out as binary.
                123 in decimal is stored as 1111011 in memory.

                The & operator is a bitwise "And".
                The result is the bits that are turned on in both numbers.

                1001 & 1100 = 1000, since only the first bit is turned on in both.

                It will be nicer to look like this

                1001 &
                1100
                =
                1000

                Note that ones only appear in a place when both arguments have a one in that place.

             */
            int bitWiseAND = checker & leftShift;
            String leftShiftBinaryString = Integer.toBinaryString(leftShift);
            String checkerBinaryString = leftPad(Integer.toBinaryString(checker), leftShiftBinaryString.length());
            String leftShiftBinaryStringWithPad = leftPad(leftShiftBinaryString, checkerBinaryString.length());
//            System.out.printf("%s &\n%s\n=\n%s\n\n", checkerBinaryString, leftShiftBinaryStringWithPad, Integer.toBinaryString(bitWiseAND));
            /*
            in our example with string "abcdmc"
            0 &
            1
            =
            0

            01 &
            10
            =
            0

            011 &
            100
            =
            0

            0111 &
            1000
            =
            0

            0000000001111 &
            1000000000000
            =
            0

            1000000001111 &
            0000000000100
            =
            100
             */
//            System.out.println(c + "," + val + "," + Integer.toBinaryString(val) + "," + leftShift + "," + Integer.toBinaryString(leftShift) + "," + checker);
            /*
            char val valBinaryString leftShift leftShiftBinaryString checker
            a   0       0               1       1                       0
            b   1       1               2       10                      1
            c   2       10              4       100                     3
            d   3       11              8       1000                    7
            m   12      1100            4096    1000000000000           15
            c   2       10              4       100                     4111
             */
            if (bitWiseAND > 0) {
                return false;
            }
            // setting 1 on on the left shift
            /*
            0000000001111 |
            1000000000000
            =
            1000000001111
             */
            checker = checker | leftShift;
        }
        return true;
        /*
        If we can't use additional data structures, we can do the following:
        1. Compare every character of the string to every other character of the string.
            This will take 0( n 2 ) time and 0(1) space
        2. If we are allowed to modify the input string, we could sort the string in O(n log(n)) time and then linearly
            check the string for neighboring characters that are identical.
            Careful, though: many sorting algorithms take up extra space.

        These solutions are not as optimal in some respects, but might be better depending on the constraints of the problem.
         */
    }

    private static String leftPad(String s, int i) {
        StringBuilder sb = new StringBuilder(s);
        int charsToGo = i - sb.length();
        while (charsToGo > 0) {
            sb.insert(0, '0');
            charsToGo--;
        }
        return sb.toString();
    }
```

上述问题的算法如果看懂，那么在回到开篇的问题就好解决了，256个ASCII字符我们拆分到4个int中（每个int 32个bit），通过 /计算出字符位于哪个桶，在通过%计算出位于桶的哪个位置

第一步判断字符被hash到哪个桶中，第二步按照上述的算法做一次判断

```
public boolean isUnique2(String str) {
    int[] checker = new int[]{0, 0, 0, 0};
    for (int i = 0; i < str.length(); i++) {
//      判断字符位于哪个桶
      int index = str.charAt(i) / 32;
      int ch = checker[index];
//      判断字符在桶中的位置
      int pos = str.charAt(i) % 32;
      if ((ch & (1 << pos)) > 0) {
        return false;
      }
      checker[index] = ch | (1 << pos);
    }
    return true;
  }
```

