位运算即是在位级别进行操作的技术，合适的位运算能够帮助我们得到更快地运算速度与更小的内存使用。

**注意：这里的k应该从0开始计算，例如第三位，k实际是使用2**

- 测试第 k 位: `s & (1 << k)` ，如果结果大于0，说明第k位为1；等于0，说明第k位为0
- 设置第 k 位: `s |= (1 << k)`，第k位会被设置为1
- 第 k 位置零: `s &= ~(1 << k)` 在使用按位非运算`~(1 << k)`后，只有第k位为0，然后在与原值做按位与操作，因为k位为0，所以第k位永远为0
- 切换第 k 位值: `s ^= (1 << k);` 在使用按位非运算`~(1 << k)`后，只有第k位为1，然后在与原值做按位异或操作，因为k位为1，取到的结果永远与原来的k位相反
- 乘以 2的n次方: `s << n` 左移
- 除以 2的n次方: `s >> n` 右移
- 交集: `s & t` 按位与计算
- 并集: `s | t` 按位或计算
- 减法: `s & ~t`
- 取出最小非 0 位（Extract lowest set bit）: `s & (-s)`
- 取出最小 0 位（Extract lowest unset bit）: `~s & (s + 1)`
- 交换值:`x ^= y; y ^= x; x ^= y;` 有关异或运算的结论:针对同一个数据异或两次,该数本身不变,比如：`a^b^b=a,a^b^a=b`；那么第二步`y ^=x`实际上就是 y =x ^ y ^ y 即x；第二步实际上就是 x = x ^ y ^ x即y




> 　在计算机中，负数以其正值的补码形式表达，方法为其绝对值求反加一。
> 　　例如 -100的绝对值为100
> 　　100原码：1000 0000 0110 0100
> 　　100反码：1111 1111 1001 1011
> 　　100补码：1111 1111 1001 1100=1111 1111 1001 1011（反码） +1
> 　　所以-100二进制表示为：1111 1111 1001 1100
> 　　原码：一个整数按绝对值大小转换成的二进制数称为原码；
> 　　反码：将二进制数按位取反，所得的新二进制数称为原二进制数的反码；（取反操作：1变0,0变1）
> 　　补码：反码加1称为补码。
>