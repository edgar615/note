https://cachecloud.github.io/2017/02/16/Redis%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/

#maxmemory

当redis所用的内存达到maxmemory上限时会触发相应的溢出控制策略。具体策略由参数`maxmemory-policy`控制.redis支持下列策略

- noeviction 默认值，不会删除任何数据，拒绝所有写入操作并返回错误信息。此时redis只响应读操作
- volatile-lru 根据LRU算法删除设置了超时属性的键，直到腾出足够的空间为止。如果没有可删除的键对象，回退到noeviction策略
- allkeys-lru 根据LRU算法删除键，不管数据有没有设置超时属性，直到腾出足够空间为止
- allkeys-random 随机删除所有键，直到腾出足够空间为止
- volatile-random 随机删除过期键，直到腾出足够空间为止
- volatile-ttl 根据键值对象的TTL书信，删除最近将要过期的数据，如果没有，回退到noeviction策略
- volatile-lfu  Evict using approximated LFU among the keys with an expire set.
- allkeys-lfu  Evict any key using approximated LFU.

可以通过`info stats`查看evicted_keys指标找出已删除的键数量

# redisObject
Redis存储的所有值对象在内部定义为redisObject结构体。该结构体有下面几部分组成
- type 对象类型，redis主要支出5种数据类型：string、hash、list、set、zset。可以使用`type {key}`命令查看值对象类型，键都是string类型
- encoding 内部编码类型，同一个对象采用不同编码实现内存占用存在明显差异，`object encoding {key}`查看编码
- lru:REDIS_LUR_BITS LRU计算时钟 记录对象最后一次被访问的时间。`object idletime {key}`在不更新lru字段的情况下查看当前键的空闲时间
- int refcount; 引用计数器 记录当前对象被引用的次数，用于通过引用次数回收内存，当refcount=0时，可以安全回收当前对象空间。使用`object refcount {key}`获取当前对象引用。当对象为整数且范围在0~9999时，redis可以使用共享对象的方式节省内存。
- void *ptr 数据指针 与对象的数据内容有关，如果是整数，直接存储数据，否则表示指向数据的指针。

redis3.0之后的版本对值对象是字符串，且长度<=39字节的数据，内部编码为embstr类型，字符串sds和redisObject一起分配，从而只要一次内存操作即可。
所以在高并发场景中，在条件允许的情况下，建议字符串床都控制在39字节以内。减少创建redisObject内存分配次数，从而提高内存.

## 缩减键值对象
降低redis内存使用最直接的方法就是缩减键和值的长度
- key长度：在设计键是，在完整描述业务情况下，键值越短越好。
- value长度：值对象缩减比较复杂，场景需求是把业务对象序列化成二进制数组放入redis。首先在业务上精简业务对象，去掉不必要的书信避免存储无效数据。其次应该选择更高效的序列化工具来降低字节数组大小。对应JSON等字符串，可以使用GZIP、snappy等压缩算法压缩

## 共享对象池
共享对象池是redis内部维护的0~9999的整数对象池。创建大量的redisObject存在内存开销，每个redisObject内部至少占16个字节，甚至超过了整数自身空间消耗。所有redis通过整数对象池来节约内存。除了整数值对象，其他类型如list、hash、set、zset内部元素也可以使用整数对象池，因此开发中在满足需求的前提下尽量使用整数的对象以节省内存

**开启了LRU淘汰策略后对象池无效**
**对应是ziplist编码的值对象，即使内部数据为整数也无法使用共享对象池**

## 字符串
redis使用自己实现的字符串结构：SDS
- O(1)时间复杂度获取字符串长度、已用长度、未用长度
- 可用于保存字节数组，支持安全的二进制数据存储
- 内部实现空间预分配机制，减低内存再分配次数
- 惰性删除机制，字符串缩减后的空间不释放，作为预分配空间保留

内存预分配规则：
- 第一次创建len属性=数据时间大小，free=0不做预分配
- 修改后如果已有free空间不够且数据小于1M，每次分配一倍的容量
- 修改后如果已有free空间不够且数据大于1MB，每次预分配1MB容量

**尽量减少字符串频繁修改操作如append、setrange，改为直接使用set修改字符串，降低预分配带来的内存浪费和内存碎片化**

## 字符串重构
不一定把每份数据作为字符串整体存储，像JSON就可以使用hash存储。

## 编码

- string
  - raw 动态字符串编码
  - embstr 优化内存分配的字符串编码
  - int 整数编码
- hash
  - hashtable 散列表
  - ziplist 压缩列表
- list
  - linkedlist 双向列表
  - ziplist 压缩列表
  - quicklist 3.2版本后新加
- set
  - hashtable 散列表
  - intset 整数集合编码
- zset
  - skiplist 跳跃表
  - ziiplist 压缩列表

 编码类型转换在redis写入数据时自动完成，这个过程是不可逆的

 hash,list,set,zset内部编码配置
- hash
  - hashtable 满足任意条件:value最大空间(字节)>hash-max-ziplist-value field个数>hash-max-ziplist-entries
  - ziplist 满足所有条件: value最大空间(字节)<=hash-max-ziplist-value field个数<=hash-max-ziplist-entries
- list
  - linkedlist 满足任意条件 value最大空间(字节)>list-max-ziplist-value 链表长度>list-max-ziplist-entries
  - ziplist 满足所有条件: value最大空间(字节)<=list-max-ziplist-value 链表长度<=list-max-ziplist-entries 
  - quicklist 使用新配置:list-max-ziplist-size:表示最大压缩空间或长度,最大空间使用[-5-1]范围配置，默认-2表示8KB,正整数表示最大压缩长度list-compress-depth:表示最大压缩深度，默认=0不压缩 
- set
  - hashtable 满足任意条件 元素非整数类型 集合长度>hash-max-ziplist-entries
  - intset 满足所有条件: 元素必须为整数 集合长度<=set-max-intset-entries
- zset
  - skiplist 满足任意条件: value最大空间(字节)>zset-max-ziplist-value 有序集合长度>zset-max-ziplist-entries
  - ziiplist 满足所有条件: value最大空间(字节)<=zset-max-ziplist-value 有序集合长度<=zset-max-ziplist-entries

 ziplist不做描述，

## 控制键的数量
当使用redis存储大量数据的时候，通常会存在大量键，过多的键会销毁大量内存。对应存储相同的数据内容可以利用redis的数据结构降低外层键的数量，可以节约大量内存。例如可以把大量键分组映射到多个hash结构中降低键的数量。（注意hash中value不要超过hash-max-ziplist-value的设置，如果使用hashtable反而会增加内存消耗）
注意：
- hash类型节省内存的原理是使用ziplist编码，如果使用hashtable编码方式反而会增加内存消耗。
- ziplist长度需要控制在1000以内，否则由于存取操作时间复杂度在O(n)到O(n2)之间，长列表会导致CPU消耗严重，得不偿失。
- ziplist适合存储的小对象，对于大对象不但内存优化效果不明显还会增加命令操作耗时。
- 需要预估键的规模，从而确定每个hash结构需要存储的元素数量。
- 根据hash长度和元素大小，调整hash-max-ziplist-entries和hash-max-ziplist-value参数，确保hash类型使用ziplist编码。

关于hash键和field键的设计：
- 当键离散度较高时，可以按字符串位截取，把后三位作为哈希的field，之前部分作为哈希的键。如：key=1948480 哈希key=group:hash:1948，哈希field=480。
- 当键离散度较低时，可以使用哈希算法打散键，如:使用crc32(key)&10000函数把所有的键映射到“0-9999”整数范围内，哈希field存储键的原始值。
- 尽量减少hash键和field的长度，如使用部分键内容。

使用hash结构控制键的规模虽然可以大幅降低内存，但同样会带来问题，需要提前做好规避处理。如下:

- 客户端需要预估键的规模并设计hash分组规则，加重客户端开发成本。
- hash重构后所有的键无法再使用超时(expire)和LRU淘汰机制自动删除，需要手动维护删除。
- 对于大对象，如1KB以上的对象。使用hash-ziplist结构控制键数量。
- 不过瑕不掩瑜，对于大量小对象的存储场景，非常适合使用ziplist编码的hash类型控制键的规模来降低内存。
	
使用ziplist+hash优化keys后，如果想使用超时删除功能，开发人员可以存储每个对象写入的时间，再通过定时任