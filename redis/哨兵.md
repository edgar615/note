https://segmentfault.com/a/1190000002680804



Redis-Sentinel是Redis官方推荐的高可用性(HA)解决方案，当用Redis做Master-slave的高可用方案时，假如master宕机了，Redis本身(包括它的很多客户端)都没有实现自动进行主备切换，而Redis-sentinel本身也是一个独立运行的进程，它能监控多个master-slave集群，发现master宕机后能进行自动切换。

Redis-Sentinel是一个分布式架构，其中包含若干个sentinel节点和redis数据节点，每个sentinel节点会对数据节点和其余sentinel节点进行监控，当它发现节点不可达时，会对节点做下线标识。如果被标识的是主节点，它还会和其他sentinel节点进行协商，当大多数sentinel节点都认为主节点不可达时，它们会选举出一个sentinel节点来完成自动故障转移的工作，同时会将这个变化实时通知给redis应用方。

![架构](http://tektea-img.b0.upaiyun.com/blog/2017/06/1.webp_23.jpg)

![架构](http://tektea-img.b0.upaiyun.com/blog/2017/06/2.webp_21.jpg)

**Redis Sentinel主要作用**

- 监控(Monitoring)：Sentinel 会不断地检查你的主服务器和从服务器是否运作正常。
- 提醒(Notification)：当被监控的某个Redis服务器出现问题时， Sentinel可以通过API向管理员或者其他应用程序发送通知。
- 自动故障迁移(Automatic failover)：当一个主服务器不能正常工作时， Sentinel会开始一次自动故障迁移操作，它会将失效主服务器的其中一个从服务器升级为新的主服务器，并让失效主服务器的其他从服务器改为复制新的主服务器；当客户端试图连接失效的主服务器时，集群也会向客户端返回新主服务器的地址，使得集群可以使用新主服务器代替失效服务器。



# 部署

物理结构

- master 6379
- slave-1 6380
- slave-2 6381
- sentinel-1 26379
- sentinel-2 26380
- sentinel-3 26381

主从的部署不做描述，下面着重看sentinel的部署

sentinel的配置文件sentinel.conf

`sentinel monitor mymaster 127.0.0.1 6379 2`代表sentinel节点需要监控127.0.0.1:6379这个主节点，2代表主节点失败至少需要2个sentinel节点统一，mymaster是主节点的别名

## 启动sentinel节点

1.使用redis-sentinel命令

```
./src/redis-sentinel sentinel.conf
```



2.使用redis-server命令加--sentinal参数

```
./redis-server /etc/sentinel.conf --sentinel
```

## 确认sentinel状态

```
./src/redis-cli -p 26379 info sentinel
# Sentinel
sentinel_masters:1
sentinel_tilt:0
sentinel_running_scripts:0
sentinel_scripts_queue_length:0
sentinel_simulate_failure_flags:0
master0:name=mymaster,status=ok,address=127.0.0.1:6379,slaves=2,sentinels=3
```

每个sentinel节点的myid要唯一

`sentinel myid 51f1d3b37129a7d7595d08efc2e171aba62d45f5`

启动后重新打开sentinel.conf，发送redis自动添加了一下配置参数

```
#发现两个slave节点
sentinel known-slave mymaster 127.0.0.1 6380
sentinel known-slave mymaster 127.0.0.1 6381
#发现两个sentinel节点
sentinel known-sentinel mymaster 127.0.0.1 26380 51f1d3b37129a7d7595d08efc2e171aba62d45f5
sentinel known-sentinel mymaster 127.0.0.1 26381 51f1d3b37129a7d7595d08efc2e171aba62d45f6
sentinel current-epoch 0
```

# 配置

```
sentinel monitor <master-name> <ip> <redis-port> <quorum>
sentinel monitor mymaster 127.0.0.1 6379 2
```

- `<ip> <redis-port>`当前Sentinel节点监控 127.0.0.1:6379 这个主节点
- `<quorum>`2代表判断主节点失败至少需要2个Sentinel节点节点同意，一般建议将其设置为sentinel节点的一半加1
- `<master-name>` mymaster是主节点的别名

quorum还和sentinel节点的领导者选举有关，至少要有max(quorum, num(sentinel)/2 + 1)个sentinel节点参与选举才能选出领导者sentinel

```
sentinel down-after-milliseconds <master-name> <milliseconds>
```

`down-after-milliseconds`选项指定了Sentinel认为服务器已经断线所需的毫秒数。如果服务器在给定的毫秒数之内，没有返回Sentinel发送的PING命令的回复，或者返回一个错误，那么Sentinel将这个服务器标记为主观下线(subjectively down，简称SDOWN)。

不过只有一个Sentinel将服务器标记为主观下线并不一定会引起服务器的自动故障迁移，只有在足够数量的Sentinel都将一个服务器标记为主观下线之后，服务器才会被标记为客观下线(objectively down，简称ODOWN)， 这时自动故障迁移才会执行。将服务器标记为客观下线所需的Sentinel数量由对主服务器的配置(sentinel monitor参数)决定。

`down-after-milliseconds`越大，代表sentinel节点对节点不可达的条件越宽松，反之就越严格。条件宽松意味着应用方故障时间可能越长，条件严格虽然可以及时发现故障完成故障转移，但是也存在一定的误判率

```
sentinel parallel-syncs <master-name> <numslaves>
```

`parallel-syncs`选项指定了在执行故障转移时，最多可以有多少个从服务器同时对新的主服务器进行同步。这个数字越小，完成故障转移所需的时间就越长。

如果从服务器被设置为允许使用过期数据集(`slave-serve-stale-data`选项)， 那么你可能不希望所有从服务器都在同一时间向新的主服务器发送同步请求。因为尽管复制过程的绝大部分步骤都不会阻塞从服务器，但从服务器在载入主服务器发来的RDB文件时，仍然会造成从服务器在一段时间内不能处理命令请求。

如果全部从服务器一起对新的主服务器进行同步，那么就可能会造成所有从服务器在短时间内全部不可用的情况出现。你可以通过将这个值设为1来保证每次只有一个从服务器处于不能处理命令请求的状态。

```
sentinel failover-timeout <master-name> <milliseconds>
```

failover-timeout作用于故障转移的各个阶段：

a）选出合适从节点

b）晋升选出的从节点为主节点

c）命令其余从节点复制新的主节点

d）等待原主节点恢复后命令它去复制新的主节点

如果sentinel对一个主节点故障转移失败，那么下次再对该主节点做故障转移的起始时间是failover-timeout的2倍。

在b)阶段，如果sentinel节点向a）阶段选出来的从节点执行`slaveof no one`一直失败，当此过程超过failover-timeout时，认为故障转移失败

在b阶段如果执行成功，sentinel还会继续执行info命令来确认a)阶段选出来的节点确实晋升为主节点，如果此过程执行时间超过failover-timeout时，则故障转移失败

如果c）节点执行时间超过了failover-timeout（不包含复制时间），则故障转移失败。但是即使超过了这个时间，sentinel节点也会最终配置从节点去同步最新的主节点

> 如果在多少毫秒内没有把宕掉的那台Master恢复，那Sentinel认为这是一次真正的宕机。在下一次选取时排除该宕掉的Master作为可用的节点，然后等待一定的设定值的毫秒数后再来探测该节点是否恢复，如果恢复就把它作为一台Slave加入Sentinel监测节点群，并在下一次切换时为他分配一个”选取号”。

```
sentinel auth-pass mymaster MySUPER--secret-0123passw0rd
```

当Master设置了密码时，Sentinel连接Master和Slave时需要通过设置参数`auth-pass`配置相应密码。

```
sentinel notification-script <master-name> <script-path>
```

指定Sentinel检测到该监控的Redis实例failover时调用的报警脚本。脚本被允许执行的最大时间为60秒，超过这个时间脚本会被kill。该配置项可选，但线上系统建议配置。这里的通知脚本简单的记录一下failover事件。

> ```
> # 创建通知脚本
> $ vim /etc/redis/notify.sh
>
> #! /bin/bash
> #获取所有参数
> msg=$*
> #报警脚本
> echo "master failovered at `date`" > /var/log/redis/redis_issues.log
> exit 0
>
> # 给脚本增加执行权限
> $ chmod +x /etc/redis/notify.sh
> ```

如果脚本以`exit 1`结束，脚本稍后重试执行，如果以`exit 2`或更高值结束，脚本不会重试，正常返回值是`exit 0`

```
sentinel client-reconfig-script <master-name> <script-path>
```

在故障转移结束后执行的脚本，该配置项可选，但线上系统建议配置。



sentinel也支持监控多个主节点，只需要知道多个mastername来区分不同的主节点即可

```
sentinel monitor mymaster 127.0.0.1 6379 2
sentinel down-after-milliseconds mymaster 60000
sentinel failover-timeout mymaster 180000
sentinel parallel-syncs mymaster 1

sentinel monitor resque 192.168.1.3 6380 4
sentinel down-after-milliseconds resque 10000
sentinel failover-timeout resque 180000
sentinel parallel-syncs resque 5
```



sentinel也只支持通过`sentinel set <param> <value>`动态设置参数，它仅对当前sentinel节点有效，而且执行成功后会立即刷新配置文件



# API

进入客户端`redis-cli -p 26379`

```
sentinel masters
```
展示所有被监控的主节点状态以及相关统计信息

```
sentinel master <master name>
```
展示指定<master name>的主节点的状态以及相关统计信息
```
sentinel slaves <master name>
```
展示指定<master name>的从节点的状态以及相关统计信息
```
sentinel sentinels <master name>
```
展示指定<master name>的sentinel节点集合（不包含当前sentinel节点）
```
sentinel get-master-addr-by-name <master name>
```
返回指定<master name>主节点的ip和端口
```
127.0.0.1:26379> sentinel get-master-addr-by-name mymaster
1) "192.168.225.128"
2) "6379"
```
```
 sentinel reset <pattern>
```
当前sentinel对符合pattern（通配符风格）主节点进行重置，包含清除主节点的相关状态（例如故障转移），重新发现重节点和sentinel节点
`sentinel reset mymaster`  sentinel-1节点对mymaster节点重置状态
```
sentinel failover <master name>
```
对指定<master name>主节点进行强制故障转移（没有和其他sentinel节点协商）故障转移完成后，其他的sentinel节点按照故障转移的结果更新自身配置（该命令在日常运维中非常有用）
示例
```
127.0.0.1:26379> sentinel failover mymaster
OK
127.0.0.1:26379> info sentinel
# Sentinel
sentinel_masters:1
sentinel_tilt:0
sentinel_running_scripts:0
sentinel_scripts_queue_length:0
sentinel_simulate_failure_flags:0
master0:name=mymaster,status=ok,address=127.0.0.1:6381,slaves=2,sentinels=3
```

```
sentinel ckquorum <master name>
```

检测当前可达的sentinel节点总数是否达到quorum的个数

```
sentinel remove <master name>
```
取消当前sentinel节点对于指定master name主节点的监控

```
sentinel monitor <master name> <ip> <port> <quorum>
```
如：sentinel monitor mymaster-1 192.168.225.128 6379 2
和配置文件中该行命令的作用相同

# 使用发布与订阅功能
 通过接收 Sentinel 发送的通知： 当执行故障转移操作， 或者某个被监视的实例被判断为主观下线或者客观下线时， Sentinel 就会发送相应的信息。
一个频道能够接收和这个频道的名字相同的事件。 比如说， 名为 +sdown 的频道就可以接收所有实例进入主观下线（SDOWN）状态的事件。
通过执行 PSUBSCRIBE * 命令可以接收所有事件信息。
进行一次主动的failover，各个频道的输出中涉及了新纪元（epoch）通知、投票、选举、新主和新slave的通告、角色转变通知，最终完成了这次主动failover过程。
例如：
```
127.0.0.1:26379> PSUBSCRIBE *
Reading messages... (press Ctrl-C to quit)
1) "psubscribe"
2) "*"
3) (integer) 1
1) "pmessage"
2) "*"
3) "+new-epoch"
4) "2"
1) "pmessage"
2) "*"
3) "+try-failover"
4) "master mymaster 127.0.0.1 6381"
1) "pmessage"
2) "*"
3) "+vote-for-leader"
4) "51f1d3b37129a7d7595d08efc2e171aba62d45f4 2"
1) "pmessage"
2) "*"
3) "+elected-leader"
4) "master mymaster 127.0.0.1 6381"
1) "pmessage"
2) "*"
3) "+failover-state-select-slave"
4) "master mymaster 127.0.0.1 6381"
1) "pmessage"
2) "*"
3) "+selected-slave"
4) "slave 127.0.0.1:6379 127.0.0.1 6379 @ mymaster 127.0.0.1 6381"
1) "pmessage"
2) "*"
3) "+failover-state-send-slaveof-noone"
4) "slave 127.0.0.1:6379 127.0.0.1 6379 @ mymaster 127.0.0.1 6381"
1) "pmessage"
2) "*"
3) "+failover-state-wait-promotion"
4) "slave 127.0.0.1:6379 127.0.0.1 6379 @ mymaster 127.0.0.1 6381"
1) "pmessage"
2) "*"
3) "-role-change"
4) "slave 127.0.0.1:6379 127.0.0.1 6379 @ mymaster 127.0.0.1 6381 new reported role is master"
1) "pmessage"
2) "*"
3) "+promoted-slave"
4) "slave 127.0.0.1:6379 127.0.0.1 6379 @ mymaster 127.0.0.1 6381"
1) "pmessage"
2) "*"
3) "+failover-state-reconf-slaves"
4) "master mymaster 127.0.0.1 6381"
1) "pmessage"
2) "*"
3) "+slave-reconf-sent"
4) "slave 127.0.0.1:6380 127.0.0.1 6380 @ mymaster 127.0.0.1 6381"
1) "pmessage"
2) "*"
3) "+slave-reconf-inprog"
4) "slave 127.0.0.1:6380 127.0.0.1 6380 @ mymaster 127.0.0.1 6381"
1) "pmessage"
2) "*"
3) "+slave-reconf-done"
4) "slave 127.0.0.1:6380 127.0.0.1 6380 @ mymaster 127.0.0.1 6381"
1) "pmessage"
2) "*"
3) "+failover-end"
4) "master mymaster 127.0.0.1 6381"
1) "pmessage"
2) "*"
3) "+switch-master"
4) "mymaster 127.0.0.1 6381 127.0.0.1 6379"
1) "pmessage"
2) "*"
3) "+slave"
4) "slave 127.0.0.1:6380 127.0.0.1 6380 @ mymaster 127.0.0.1 6379"
1) "pmessage"
2) "*"
3) "+slave"
4) "slave 127.0.0.1:6381 127.0.0.1 6381 @ mymaster 127.0.0.1 6379"
1) "pmessage"
2) "*"
3) "-role-change"
4) "slave 127.0.0.1:6381 127.0.0.1 6381 @ mymaster 127.0.0.1 6379 new reported role is master"
1) "pmessage"
2) "*"
3) "+role-change"
4) "slave 127.0.0.1:6381 127.0.0.1 6381 @ mymaster 127.0.0.1 6379 new reported role is slave"
```
以下列出的是客户端可以通过订阅来获得的频道和信息的格式：第一个英文单词是频道/事件的名字，其余的是数据的格式。

注意，当格式中包含 `instance details` 字样时，表示频道所返回的信息中包含了以下用于识别目标实例的内容：

```
<instance-type> <name> <ip> <port> @ <master-name> <master-ip> <master-port>

```

`@` 字符之后的内容用于指定主服务器，这些内容是可选的，它们仅在 `@` 字符之前的内容指定的实例不是主服务器时使用。

- `+reset-master <instance details>` ：主服务器已被重置。
- `+slave <instance details>` ：一个新的从服务器已经被 Sentinel 识别并关联。
- `+failover-state-reconf-slaves <instance details>` ：故障转移状态切换到了 `reconf-slaves` 状态。
- `+failover-detected <instance details>` ：另一个 Sentinel 开始了一次故障转移操作，或者一个从服务器转换成了主服务器。
- `+slave-reconf-sent <instance details>` ：领头（leader）的 Sentinel 向实例发送了 [SLAVEOF](http://redisdoc.com/server/slaveof.html#slaveof) 命令，为实例设置新的主服务器。
- `+slave-reconf-inprog <instance details>` ：实例正在将自己设置为指定主服务器的从服务器，但相应的同步过程仍未完成。
- `+slave-reconf-done <instance details>` ：从服务器已经成功完成对新主服务器的同步。
- `-dup-sentinel <instance details>` ：对给定主服务器进行监视的一个或多个 Sentinel 已经因为重复出现而被移除 —— 当 Sentinel 实例重启的时候，就会出现这种情况。
- `+sentinel <instance details>` ：一个监视给定主服务器的新 Sentinel 已经被识别并添加。
- `+sdown <instance details>` ：给定的实例现在处于主观下线状态。
- `-sdown <instance details>` ：给定的实例已经不再处于主观下线状态。
- `+odown <instance details>` ：给定的实例现在处于客观下线状态。
- `-odown <instance details>` ：给定的实例已经不再处于客观下线状态。
- `+new-epoch <instance details>` ：当前的纪元（epoch）已经被更新。
- `+try-failover <instance details>` ：一个新的故障迁移操作正在执行中，等待被大多数 Sentinel 选中（waiting to be elected by the majority）。
- `+elected-leader <instance details>` ：赢得指定纪元的选举，可以进行故障迁移操作了。
- `+failover-state-select-slave <instance details>` ：故障转移操作现在处于 `select-slave` 状态 —— Sentinel 正在寻找可以升级为主服务器的从服务器。
- `no-good-slave <instance details>` ：Sentinel 操作未能找到适合进行升级的从服务器。Sentinel 会在一段时间之后再次尝试寻找合适的从服务器来进行升级，又或者直接放弃执行故障转移操作。
- `selected-slave <instance details>` ：Sentinel 顺利找到适合进行升级的从服务器。
- `failover-state-send-slaveof-noone <instance details>` ：Sentinel 正在将指定的从服务器升级为主服务器，等待升级功能完成。
- `failover-end-for-timeout <instance details>` ：故障转移因为超时而中止，不过最终所有从服务器都会开始复制新的主服务器（slaves will eventually be configured to replicate with the new master anyway）。
- `failover-end <instance details>` ：故障转移操作顺利完成。所有从服务器都开始复制新的主服务器了。
- `+switch-master <master name> <oldip> <oldport> <newip> <newport>` ：配置变更，主服务器的 IP 和地址已经改变。 **这是绝大多数外部用户都关心的信息。**
- `+tilt` ：进入 tilt 模式。
- `-tilt` ：退出 tilt 模式。





由此可见，一次failover的过程如下：
一次故障转移操作由以下步骤组成：
(1). 由sentinel主动发起failover或者发现主服务器已经进入客观下线状态。
(2). sentinel对我们的当前纪元(epoch)进行自增，并尝试在这个纪元中当选为此次failover的总指挥。
(3). 如果当选失败， 那么在设定的故障迁移超时时间的两倍之后， 重新尝试当选。 如果当选成功， 那么执行以下步骤。
(4). 选出一个从redis实例，并将它升级为主redis实例。
(5). 向被选中的从redis实例发送 SLAVEOF NO ONE 命令，让它转变为主redis实例。
(6). 通过发布与订阅功能， 将更新后的配置传播给所有其他 Sentinel ， 其他 Sentinel 对它们自己的配置进行更新。
(7). 向已下线主服务器的从服务器发送SLAVEOF命令， 让它们去复制新的主服务器。
(8). 当所有从redis实例都已经开始复制新的主redis实例时， 领头Sentinel 终止这次故障迁移操作。

# 主观下线和客观下线
sentinel对于不可用有两种不同的看法，一个叫主观不可用(SDOWN),另外一个叫客观不可用(ODOWN)。SDOWN是sentinel自己主观上检测到的关于master的状态，ODOWN需要一定数量的sentinel达成一致意见才能认为一个master客观上已经宕掉，各个sentinel之间通过命令SENTINEL is_master_down_by_addr来获得其它sentinel对master的检测结果。

从sentinel的角度来看，如果发送了PING心跳后，在一定时间内没有收到合法的回复，就达到了SDOWN的条件。这个时间在配置中通过is-master-down-after-milliseconds参数配置。

当sentinel发送PING后，以下回复之一都被认为是合法的：

PING replied with +PONG.
PING replied with -LOADING error.
PING replied with -MASTERDOWN error.

其它任何回复（或者根本没有回复）都是不合法的。

从SDOWN切换到ODOWN不需要任何一致性算法，只需要一个gossip协议：如果一个sentinel收到了足够多的sentinel发来消息告诉它某个master已经down掉了，SDOWN状态就会变成ODOWN状态。如果之后master可用了，这个状态就会相应地被清理掉。

正如之前已经解释过了，真正进行failover需要一个授权的过程，但是所有的failover都开始于一个ODOWN状态。

ODOWN状态只适用于master，对于不是master的redis节点sentinel之间不需要任何协商，slaves和sentinel不会有ODOWN状态。
