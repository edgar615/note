主从复制 

## 建立主从复制
redis有三种方式建立主从复制

1. 在从节点的配置文件上加入`slaveof <masterip> <masterport>`
2. 在从节点的redis-server启动命令后加上 `./redis-server --slaveof <masterip> <masterport>`
3. 在从节点上使用命令 `slaveof <masterip> <masterport>`

示例
**启动主节点**
	src/redis-server 
**启动从节点**，注意避免使用主节点的持久化文件加载
	src/redis-server --port 6380 
**主节点上有一个key**
    127.0.0.1:6379> DBSIZE
    (integer) 1
    127.0.0.1:6379> keys *
    1) "foo"
**建立主从复制之前，从库没有KEY**
    127.0.0.1:6380> dbsize
    (integer) 0
**建立主从复制**
    127.0.0.1:6380> slaveof 127.0.0.1 6379
    OK
**主节点的日志如下**
    27984:M 21 Nov 16:42:44.889 * Slave 127.0.0.1:6380 asks for synchronization
    27984:M 21 Nov 16:42:44.890 * Partial resynchronization not accepted: Replication ID mismatch (Slave asked for 'b83d19387d13d6820a8190fb037b121dc80697e6', my replication IDs are 'e330daced60ae878cffc7a7e02ccb54c11d73dfe' and '0000000000000000000000000000000000000000')
    27984:M 21 Nov 16:42:44.890 * Starting BGSAVE for SYNC with target: disk
    27984:M 21 Nov 16:42:44.891 * Background saving started by pid 28075
    28075:C 21 Nov 16:42:44.894 * DB saved on disk
    28075:C 21 Nov 16:42:44.894 * RDB: 6 MB of memory used by copy-on-write
    27984:M 21 Nov 16:42:44.952 * Background saving terminated with success
    27984:M 21 Nov 16:42:44.952 * Synchronization with slave 127.0.0.1:6380 succeeded
**从节点的日志如下**
    28069:S 21 Nov 16:42:44.345 * Before turning into a slave, using my master parameters to synthesize a cached master: I may be able to synchronize with the new master with just a partial transfer.
    28069:S 21 Nov 16:42:44.345 * SLAVE OF 127.0.0.1:6379 enabled (user request from 'id=2 addr=127.0.0.1:36184 fd=7 name= age=91 idle=0 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=0 qbuf-free=32768 obl=0 oll=0 omem=0 events=r cmd=slaveof')
    28069:S 21 Nov 16:42:44.889 * Connecting to MASTER 127.0.0.1:6379
    28069:S 21 Nov 16:42:44.889 * MASTER <-> SLAVE sync started
    28069:S 21 Nov 16:42:44.889 * Non blocking connect for SYNC fired the event.
    28069:S 21 Nov 16:42:44.889 * Master replied to PING, replication can continue...
    28069:S 21 Nov 16:42:44.889 * Trying a partial resynchronization (request b83d19387d13d6820a8190fb037b121dc80697e6:1).
    28069:S 21 Nov 16:42:44.893 * Full resync from master: d7ffc06a335aa6d77dad778b8b3088d6e1212fbd:0
    28069:S 21 Nov 16:42:44.893 * Discarding previously cached master state.
    28069:S 21 Nov 16:42:44.952 * MASTER <-> SLAVE sync: receiving 189 bytes from master
    28069:S 21 Nov 16:42:44.952 * MASTER <-> SLAVE sync: Flushing old data
    28069:S 21 Nov 16:42:44.952 * MASTER <-> SLAVE sync: Loading DB in memory
    28069:S 21 Nov 16:42:44.953 * MASTER <-> SLAVE sync: Finished with success
**建立主从复制之后，从库有了key**
    127.0.0.1:6380> dbsize
    (integer) 1
    127.0.0.1:6380> get foo
    "bar"

slaveof是一个异步命令，执行slaveof时，节点只保存主节点信息后返回，后续复制流程在节点内部异步执行。可以使用`info replication`查看复制状态
**主节点**

    127.0.0.1:6379> info replication
    # Replication
    role:master
    connected_slaves:1
    slave0:ip=127.0.0.1,port=6380,state=online,offset=690,lag=0
    master_replid:d7ffc06a335aa6d77dad778b8b3088d6e1212fbd
    master_replid2:0000000000000000000000000000000000000000
    master_repl_offset:690
    second_repl_offset:-1
    repl_backlog_active:1
    repl_backlog_size:1048576
    repl_backlog_first_byte_offset:1
    repl_backlog_histlen:690

**从节点**

    127.0.0.1:6380> info replication
    # Replication
    role:slave
    master_host:127.0.0.1
    master_port:6379
    master_link_status:up
    master_last_io_seconds_ago:9
    master_sync_in_progress:0
    slave_repl_offset:606
    slave_priority:100
    slave_read_only:1
    connected_slaves:0
    master_replid:d7ffc06a335aa6d77dad778b8b3088d6e1212fbd
    master_replid2:0000000000000000000000000000000000000000
    master_repl_offset:606
    second_repl_offset:-1
    repl_backlog_active:1
    repl_backlog_size:1048576
    repl_backlog_first_byte_offset:1
    repl_backlog_histlen:606

## 断开复制
在从节点执行`slaveof no one`可以断开与主节点复制关系。从节点断开复制后并不会抛弃原有数据，只是无法再获取主节点上的数据变化

## 切换主 节点
在从节点上通过`slaveof <masterip> <masterport>``命令可以把当前从节点对主节点的复制切换到另一个主节点：
1. 断开与旧主节点复制关系
2. 与新主就节点建立复制关系
3. 删除从节点当前所有数据
4. 对新主节点进行复制操作

## 安全设置
**主节点密码**

	masterauth <master-password>

**从库设为只读**

	slave-read-only yes

**网络延迟**

	repl-disable-tcp-nodelay no#是否关闭TCP_NODELAY

- 当关闭时，主节点产生的命令数据无论大小都会及时地发送给从节点，这样主从之间的延迟会变小，但增加了网络带宽的消耗，适用于主从之间的网络环境良好的场景。
- 当开启时，主节点会合并较小的TCP数据包从而节省带宽。默认发送时间取决于linux的内核，一般默认为40毫秒。这种复杂节省了带宽但增大了主从之间的延迟。适用于主从网络环境复杂或者带宽紧张的场景

## 拓扑
### 一主一从
主库不开启持久化，从库开启AOF，这样既保证了数据安全性，同时也避免了持久化对主节点性能的干扰。
**注意**：因为主节点没有开启持久化，如果主节点重启后数据集为空，如果从节点继续复制主节点会导致从节点的数据也被清空。所以要先在从节点上执行`slaveof no one`断开主从复制。
### 一主多从
对于读占比较大的场景，可以把读命令发送到从节点来分担从节点压力。但对于写占比较大的场景，多个从节点会导致主就节点写命令的多次发送从而过度消耗网络带宽，同时也加重了主节点的负载影响服务稳定性
### 树状主从结构
从节点不但可以复制主就节点数据，同时可以作为其他从节点的主节点继续向下层复制。有效降低了主节点的复制和需要传送给从节点的数据量

## psync
从就节点使用psync命令可以完成部分复制和全量复制的功能

	PSYNC <MASTER_RUN_ID> <OFFSET>

MASTER_RUN_ID: 从节点所复制主节点的运行ID
offset：当前从节点已复制的数据偏移量

## 其他配置
repl-timeout 60 #从节点超时时间，单位秒
repl-ping-slave-period 10 #主节点对从节点发起ping的间隔，单位秒